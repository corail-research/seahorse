{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>SEAHORSE <p> </p> <p>Download Stars Issue</p>"},{"location":"#a-handy-package-for-kickstarting-ai-contests","title":"A handy package for kickstarting AI contests","text":"<p>We proudly provide a Python framework that makes the building of an environment for adversarial search agents easy! </p> <p>A lot of fun functionalities are provided an easily usable out of the box! </p> <ul> <li>Implementing a new game setup from scratch? Painless!</li> <li>Playing against remote agents? Easy! </li> <li>Generating and collecting data about played games? Worriless!</li> <li>Organizing a contest for a large range of agents? Quick and reliable!</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>The package is publicly available on PyPI.</p> <p>We strongly encourage the use of a virtual environment:</p> <pre><code>    $ python3 -m venv venv\n\n    $ source venv/bin/[activate|Activate.ps1]\n\n    (venv)$ pip install seahorse\n</code></pre>"},{"location":"#running-the-example","title":"Running the example","text":"Initial state Intermediate state Final state <p>An example implementation featuring the famous game of tic-tac-toe is available on the github repository under the branch with its name:</p> <pre><code>git clone https://github.com/corail-research/seahorse/ \\\n--branch tictactoe \\\n--single-branch tictactoe\n</code></pre> <p>Learn on how to launch the example and recreate one of your own through our tutorials</p>"},{"location":"#main-contributors","title":"Main contributors","text":"<p>We are an enthusiastic team of M.Sc candidates led by Pr. Quentin Cappart at Polytechnique Montr\u00e9al. The package was originally developed in the context of a introductory course to artificial intelligence given to undergrad computer and software engineering students.</p> Quentin Cappart <p>Professor &amp; team lead</p> Amaury Guichard <p>UX Design &amp; architecture</p> Lo\u00efc Grumiaux <p>Networking &amp; DevOps</p> Thomas Jacquet <p>Algorithms &amp; architecture</p> Louis Gillon <p>Architecture &amp; parallelization</p> <p></p> <p></p>"},{"location":"overview/networking/","title":"Networking","text":"<p>Here you will find some insights on how the internals of Seahorse work and hopefully when you are done reading this you will understand how the networking features were brought to life.</p>"},{"location":"overview/networking/#an-master-slave-mechanism","title":"An master-slave mechanism","text":"<pre><code>graph TD\n  M{Master};\n  M &lt;--&gt; C[GUIClient];\n  M &lt;--&gt; F[StateRecorder];\n  M &lt;--&gt; D(Player #1);\n  M &lt;--&gt; E(Player #2);\n  M &lt;--&gt; G[SocketIO client];</code></pre>"},{"location":"overview/networking/#proxies","title":"Proxies","text":""},{"location":"overview/networking/#in-house-handshake","title":"In-house handshake","text":"<pre><code>sequenceDiagram\n  autonumber\n  Client-&gt;&gt;Server: Connexion request\n  Server-&gt;&gt;Client: Connexion accepted\n  Client-&gt;&gt;Server: Identifier : \"Bob\"\n  loop wait for states\n      Client-&gt;&gt;Client: sleep\n      Server-&gt;&gt;Client: State (+ action request)\n      Client--&gt;&gt;Server: (Action)\n  end\n  Server-&gt;&gt;Client: Terminate connexion</code></pre>"},{"location":"overview/objects/","title":"Objects","text":"<pre><code>classDiagram\n\n  GameState *--  Action\n  Action *--\"2\"  GameState\n  GameMaster *-- GameState\n  GameState *--\"1\" Representation\n  Representation &lt;|-- Board\n  Board *-- Piece\n  GameMaster *-- Player\n  GameState *-- Player\n\n  class GameState{\n    +Representation rep\n    +dict[int, Any] scores\n    +Player next_player\n    +list[Player] players\n    +list[Action] _possible_actions\n    +GameState(scores, next_player, players, rep)  \n    +get_player_score(player) float\n    +compute_next_player() Player\n    +check_action(action) bool\n    +generate_possible_actions()* Set[Action]\n    +compute_scores(next_rep)* dict[int, Any]\n    +is_done()* bool\n  }\n\n  class Action{\n    +GameState past_gs \n    +GameState next_gs\n    +Action(past_gs, next_gs)\n    +get_current_game_state() GameState\n    +get_next_game_state() GameState\n  }\n\n  class GameMaster{\n    +EventMaster emitter\n    +GameState current_game_state\n    +String name\n    +GameState initial_game_state\n    +list[Player] players\n    +String log_level\n    +GameMaster(name,initial_game_state,players_iterator,log_level,port,hostname)\n    +step()\n    +play_game() list[Player]\n    +record_game(listeners)\n    +update_log()\n    +compute_winner(scores)* list[Player] \n  }\n\n  class Representation{\n    +Dict env\n    +Representation(env)\n    +find(to_find) Any\n  }\n\n  class Board{\n    +list[int] dimensions\n    +get_pieces_player(owner) tuple[int, list[Piece]]\n  }\n\n  class Piece{\n    +str piece_type\n    +int owner_id\n  }\n\n  class Player{\n    +int id\n    +str name\n    +Player(name, id, time_limit)\n    +play(game_state) Action\n    +compute_action(...)* Action\n  }</code></pre>"},{"location":"reference/seahorse/game/action/","title":"Action","text":""},{"location":"reference/seahorse/game/action/#seahorse.game.action.Action","title":"<code>Action</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>A generic class representing an action in the game.</p> Source code in <code>src/seahorse/game/action.py</code> <pre><code>class Action(Serializable):\n    \"\"\"\n    A generic class representing an action in the game.\n\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initializes a new instance of the Action class.\n\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_heavy_action(self, *_) -&gt; Action:\n        \"\"\"\n        Returns the heavy action.\n\n        Returns:\n            Action: The heavy action.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/seahorse/game/action/#seahorse.game.action.Action.__init__","title":"<code>__init__()</code>","text":"<p>Initializes a new instance of the Action class.</p> Source code in <code>src/seahorse/game/action.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initializes a new instance of the Action class.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/seahorse/game/action/#seahorse.game.action.Action.get_heavy_action","title":"<code>get_heavy_action(*_)</code>  <code>abstractmethod</code>","text":"<p>Returns the heavy action.</p> <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>The heavy action.</p> Source code in <code>src/seahorse/game/action.py</code> <pre><code>@abstractmethod\ndef get_heavy_action(self, *_) -&gt; Action:\n    \"\"\"\n    Returns the heavy action.\n\n    Returns:\n        Action: The heavy action.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/seahorse/game/custom_stat/","title":"Custom stat","text":""},{"location":"reference/seahorse/game/custom_stat/#seahorse.game.custom_stat.CustomStat","title":"<code>CustomStat</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>A typed dictionary class representing a custom statistic format.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The statistic name.</p> <code>value</code> <code>object</code> <p>The statistic value.</p> <code>agent_id</code> <code>int</code> <p>The Player ID to which the statistic is attributed.</p> Source code in <code>src/seahorse/game/custom_stat.py</code> <pre><code>class CustomStat(TypedDict):\n    \"\"\"\n    A typed dictionary class representing a custom statistic format.\n\n    Attributes:\n        name (str): The statistic name.\n        value (object): The statistic value.\n        agent_id (int): The Player ID to which the statistic is attributed.\n    \"\"\"\n\n    name: str\n    value: object\n    agent_id: int\n</code></pre>"},{"location":"reference/seahorse/game/game_state/","title":"Game state","text":""},{"location":"reference/seahorse/game/game_state/#seahorse.game.game_state.GameState","title":"<code>GameState</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>A class representing the game state.</p> <p>Attributes:</p> Name Type Description <code>scores</code> <code>Dict[int, Any]</code> <p>The scores of the state for each player.</p> <code>next_player</code> <code>Player</code> <p>The next player to play.</p> <code>players</code> <code>List[Player]</code> <p>The list of players.</p> <code>rep</code> <code>Representation</code> <p>The representation of the game.</p> Source code in <code>src/seahorse/game/game_state.py</code> <pre><code>class GameState(Serializable):\n    \"\"\"\n    A class representing the game state.\n\n    Attributes:\n        scores (Dict[int, Any]): The scores of the state for each player.\n        next_player (Player): The next player to play.\n        players (List[Player]): The list of players.\n        rep (Representation): The representation of the game.\n    \"\"\"\n\n    def __init__(self, scores: dict[int, Any], next_player: Player, players: list[Player], rep: Representation) -&gt; None:\n        \"\"\"\n        Initializes a new instance of the GameState class.\n\n        Args:\n            scores (Dict[int, Any]): The scores of the state for each player.\n            next_player (Player): The next player to play.\n            players (List[Player]): The list of players.\n            rep (Representation): The representation of the game.\n        \"\"\"\n        self.scores = scores\n        self.next_player = next_player\n        self.players = players\n        self.rep = rep\n        self._possible_light_actions = None\n        self._possible_heavy_actions = None\n\n    def get_player_score(self, player: Player) -&gt; float:\n        \"\"\"\n        Gets a player's score.\n\n        Args:\n            player (Player): The player.\n\n        Returns:\n            float: The score.\n        \"\"\"\n        return self.scores[player.get_id()]\n\n    def get_next_player(self) -&gt; Player:\n        \"\"\"\n        Returns the next player.\n\n        Returns:\n            Player: The next player.\n        \"\"\"\n        return self.next_player\n\n    def compute_next_player(self) -&gt; Player:\n        \"\"\"\n        Computes the next player.\n\n        Returns:\n            Player: The next player.\n        \"\"\"\n        current = self.next_player\n        curr_id = self.players.index(current)\n        return next(cycle(self.players[curr_id + 1 :] + self.players[:curr_id]))\n\n    def get_scores(self) -&gt; dict[int, float]:\n        \"\"\"\n        Returns the scores.\n\n        Returns:\n            Dict: The player ID to score mapping.\n        \"\"\"\n        return self.scores\n\n    def get_players(self) -&gt; list[Player]:\n        \"\"\"\n        Returns the list of players.\n\n        Returns:\n            List[Player]: The list of players.\n        \"\"\"\n        return self.players\n\n    def get_rep(self) -&gt; Representation:\n        \"\"\"\n        Returns the representation of the game.\n\n        Returns:\n            Representation: The game representation.\n        \"\"\"\n        return self.rep\n\n    def get_possible_light_actions(self) -&gt; frozenset[LightAction]:\n        \"\"\"\n        Returns a copy of the possible light actions from this state.\n        The first call triggers the `generate_possible_light_actions` method.\n\n        Returns:\n            FrozenSet[LightAction]: The possible actions.\n        \"\"\"\n        # Lazy loading\n        if self.is_done():\n            return frozenset()\n        if self._possible_light_actions is None:\n            self._possible_light_actions = frozenset(self.generate_possible_light_actions())\n        return self._possible_light_actions\n\n    def get_possible_heavy_actions(self) -&gt; frozenset[HeavyAction]:\n        \"\"\"\n        Returns a copy of the possible heavy actions from this state.\n        The first call triggers the `generate_possible_heavy_actions` method.\n\n        Returns:\n            FrozenSet[Action]: The possible actions.\n        \"\"\"\n        # Lazy loading\n        if self.is_done():\n            return frozenset()\n        if self._possible_heavy_actions is None:\n            self._possible_heavy_actions = frozenset(self.generate_possible_heavy_actions())\n        return self._possible_heavy_actions\n\n    def check_action(self, action: Action) -&gt; bool:\n        \"\"\"\n        Checks if an action is feasible.\n\n        Args:\n            action (Action): The action to check.\n\n        Returns:\n            bool: True if the action is feasible, False otherwise.\n        \"\"\"\n        if isinstance(action, LightAction):\n            return action in self.get_possible_light_actions()\n        if isinstance(action, HeavyAction):\n            return action in self.get_possible_heavy_actions()\n        return False\n\n    def convert_gui_data_to_action_data(self, data: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"\n        Converts GUI data to light action data.\n        This method can and should be overridden by the user.\n\n        Args:\n            data (Dict[str, Any]): The GUI data.\n\n        Returns:\n            Dict[str, Any]: The action data.\n        \"\"\"\n        return data\n\n    @abstractmethod\n    def apply_action(self, action: LightAction) -&gt; \"GameState\":\n        \"\"\"\n        Applies an action to the game state.\n\n        Args:\n            action (LightAction): The action to apply.\n\n        Returns:\n            GameState: The new game state.\n\n        Raises:\n            MethodNotImplementedError: If the method is not implemented.\n        \"\"\"\n        raise MethodNotImplementedError()\n\n    @abstractmethod\n    def generate_possible_light_actions(self) -&gt; set[LightAction]:\n        \"\"\"\n        Generates a set of all possible actions from this game state.\n\n        Returns:\n            Set[Action]: A set of possible actions.\n\n        Raises:\n            MethodNotImplementedError: If the method is not implemented.\n        \"\"\"\n        raise MethodNotImplementedError()\n\n    @abstractmethod\n    def generate_possible_heavy_actions(self) -&gt; set[HeavyAction]:\n        \"\"\"\n        Generates a set of all possible actions from this game state.\n\n        Returns:\n            Set[Action]: A set of possible actions.\n\n        Raises:\n            MethodNotImplementedError: If the method is not implemented.\n        \"\"\"\n        raise MethodNotImplementedError()\n\n    @abstractmethod\n    def convert_heavy_action_to_light_action(self, action: HeavyAction) -&gt; LightAction:\n        \"\"\"\n        Converts a heavy action to a light action.\n\n        Args:\n            action (HeavyAction): The heavy action to convert.\n\n        Returns:\n            LightAction: The converted light action.\n        \"\"\"\n        raise MethodNotImplementedError()\n\n    @abstractmethod\n    def compute_scores(self, next_rep: Representation) -&gt; dict[int, Any]:\n        \"\"\"\n        Computes the scores of each player.\n\n        Args:\n            next_rep (Representation): The next representation.\n\n        Returns:\n            Dict[int, Any]: The scores of each player.\n\n        Raises:\n            MethodNotImplementedError: If the method is not implemented.\n        \"\"\"\n        raise MethodNotImplementedError()\n\n    @abstractmethod\n    def is_done(self) -&gt; bool:\n        \"\"\"\n        Indicates if the current GameState is final.\n\n        Returns:\n            bool: True if the state is final, False otherwise.\n\n        Raises:\n            MethodNotImplementedError: If the method is not implemented.\n        \"\"\"\n        raise MethodNotImplementedError()\n\n    def __hash__(self) -&gt; int:\n        return hash((hash(frozenset(self.scores.items())), hash(self.rep)))\n\n    def __eq__(self, value: object) -&gt; bool:\n        return hash(self) == hash(value)\n\n    def __str__(self) -&gt; str:\n        to_print = f\"Current scores are {self.get_scores()}.\\n\"\n        to_print += f\"Next person to play is player {self.get_next_player().get_id()} ({self.get_next_player().get_name()}).\\n\"\n        return to_print\n</code></pre>"},{"location":"reference/seahorse/game/game_state/#seahorse.game.game_state.GameState.__init__","title":"<code>__init__(scores, next_player, players, rep)</code>","text":"<p>Initializes a new instance of the GameState class.</p> <p>Parameters:</p> Name Type Description Default <code>scores</code> <code>Dict[int, Any]</code> <p>The scores of the state for each player.</p> required <code>next_player</code> <code>Player</code> <p>The next player to play.</p> required <code>players</code> <code>List[Player]</code> <p>The list of players.</p> required <code>rep</code> <code>Representation</code> <p>The representation of the game.</p> required Source code in <code>src/seahorse/game/game_state.py</code> <pre><code>def __init__(self, scores: dict[int, Any], next_player: Player, players: list[Player], rep: Representation) -&gt; None:\n    \"\"\"\n    Initializes a new instance of the GameState class.\n\n    Args:\n        scores (Dict[int, Any]): The scores of the state for each player.\n        next_player (Player): The next player to play.\n        players (List[Player]): The list of players.\n        rep (Representation): The representation of the game.\n    \"\"\"\n    self.scores = scores\n    self.next_player = next_player\n    self.players = players\n    self.rep = rep\n    self._possible_light_actions = None\n    self._possible_heavy_actions = None\n</code></pre>"},{"location":"reference/seahorse/game/game_state/#seahorse.game.game_state.GameState.apply_action","title":"<code>apply_action(action)</code>  <code>abstractmethod</code>","text":"<p>Applies an action to the game state.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>LightAction</code> <p>The action to apply.</p> required <p>Returns:</p> Name Type Description <code>GameState</code> <code>GameState</code> <p>The new game state.</p> <p>Raises:</p> Type Description <code>MethodNotImplementedError</code> <p>If the method is not implemented.</p> Source code in <code>src/seahorse/game/game_state.py</code> <pre><code>@abstractmethod\ndef apply_action(self, action: LightAction) -&gt; \"GameState\":\n    \"\"\"\n    Applies an action to the game state.\n\n    Args:\n        action (LightAction): The action to apply.\n\n    Returns:\n        GameState: The new game state.\n\n    Raises:\n        MethodNotImplementedError: If the method is not implemented.\n    \"\"\"\n    raise MethodNotImplementedError()\n</code></pre>"},{"location":"reference/seahorse/game/game_state/#seahorse.game.game_state.GameState.check_action","title":"<code>check_action(action)</code>","text":"<p>Checks if an action is feasible.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>Action</code> <p>The action to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the action is feasible, False otherwise.</p> Source code in <code>src/seahorse/game/game_state.py</code> <pre><code>def check_action(self, action: Action) -&gt; bool:\n    \"\"\"\n    Checks if an action is feasible.\n\n    Args:\n        action (Action): The action to check.\n\n    Returns:\n        bool: True if the action is feasible, False otherwise.\n    \"\"\"\n    if isinstance(action, LightAction):\n        return action in self.get_possible_light_actions()\n    if isinstance(action, HeavyAction):\n        return action in self.get_possible_heavy_actions()\n    return False\n</code></pre>"},{"location":"reference/seahorse/game/game_state/#seahorse.game.game_state.GameState.compute_next_player","title":"<code>compute_next_player()</code>","text":"<p>Computes the next player.</p> <p>Returns:</p> Name Type Description <code>Player</code> <code>Player</code> <p>The next player.</p> Source code in <code>src/seahorse/game/game_state.py</code> <pre><code>def compute_next_player(self) -&gt; Player:\n    \"\"\"\n    Computes the next player.\n\n    Returns:\n        Player: The next player.\n    \"\"\"\n    current = self.next_player\n    curr_id = self.players.index(current)\n    return next(cycle(self.players[curr_id + 1 :] + self.players[:curr_id]))\n</code></pre>"},{"location":"reference/seahorse/game/game_state/#seahorse.game.game_state.GameState.compute_scores","title":"<code>compute_scores(next_rep)</code>  <code>abstractmethod</code>","text":"<p>Computes the scores of each player.</p> <p>Parameters:</p> Name Type Description Default <code>next_rep</code> <code>Representation</code> <p>The next representation.</p> required <p>Returns:</p> Type Description <code>dict[int, Any]</code> <p>Dict[int, Any]: The scores of each player.</p> <p>Raises:</p> Type Description <code>MethodNotImplementedError</code> <p>If the method is not implemented.</p> Source code in <code>src/seahorse/game/game_state.py</code> <pre><code>@abstractmethod\ndef compute_scores(self, next_rep: Representation) -&gt; dict[int, Any]:\n    \"\"\"\n    Computes the scores of each player.\n\n    Args:\n        next_rep (Representation): The next representation.\n\n    Returns:\n        Dict[int, Any]: The scores of each player.\n\n    Raises:\n        MethodNotImplementedError: If the method is not implemented.\n    \"\"\"\n    raise MethodNotImplementedError()\n</code></pre>"},{"location":"reference/seahorse/game/game_state/#seahorse.game.game_state.GameState.convert_gui_data_to_action_data","title":"<code>convert_gui_data_to_action_data(data)</code>","text":"<p>Converts GUI data to light action data. This method can and should be overridden by the user.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>The GUI data.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dict[str, Any]: The action data.</p> Source code in <code>src/seahorse/game/game_state.py</code> <pre><code>def convert_gui_data_to_action_data(self, data: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"\n    Converts GUI data to light action data.\n    This method can and should be overridden by the user.\n\n    Args:\n        data (Dict[str, Any]): The GUI data.\n\n    Returns:\n        Dict[str, Any]: The action data.\n    \"\"\"\n    return data\n</code></pre>"},{"location":"reference/seahorse/game/game_state/#seahorse.game.game_state.GameState.convert_heavy_action_to_light_action","title":"<code>convert_heavy_action_to_light_action(action)</code>  <code>abstractmethod</code>","text":"<p>Converts a heavy action to a light action.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>HeavyAction</code> <p>The heavy action to convert.</p> required <p>Returns:</p> Name Type Description <code>LightAction</code> <code>LightAction</code> <p>The converted light action.</p> Source code in <code>src/seahorse/game/game_state.py</code> <pre><code>@abstractmethod\ndef convert_heavy_action_to_light_action(self, action: HeavyAction) -&gt; LightAction:\n    \"\"\"\n    Converts a heavy action to a light action.\n\n    Args:\n        action (HeavyAction): The heavy action to convert.\n\n    Returns:\n        LightAction: The converted light action.\n    \"\"\"\n    raise MethodNotImplementedError()\n</code></pre>"},{"location":"reference/seahorse/game/game_state/#seahorse.game.game_state.GameState.generate_possible_heavy_actions","title":"<code>generate_possible_heavy_actions()</code>  <code>abstractmethod</code>","text":"<p>Generates a set of all possible actions from this game state.</p> <p>Returns:</p> Type Description <code>set[HeavyAction]</code> <p>Set[Action]: A set of possible actions.</p> <p>Raises:</p> Type Description <code>MethodNotImplementedError</code> <p>If the method is not implemented.</p> Source code in <code>src/seahorse/game/game_state.py</code> <pre><code>@abstractmethod\ndef generate_possible_heavy_actions(self) -&gt; set[HeavyAction]:\n    \"\"\"\n    Generates a set of all possible actions from this game state.\n\n    Returns:\n        Set[Action]: A set of possible actions.\n\n    Raises:\n        MethodNotImplementedError: If the method is not implemented.\n    \"\"\"\n    raise MethodNotImplementedError()\n</code></pre>"},{"location":"reference/seahorse/game/game_state/#seahorse.game.game_state.GameState.generate_possible_light_actions","title":"<code>generate_possible_light_actions()</code>  <code>abstractmethod</code>","text":"<p>Generates a set of all possible actions from this game state.</p> <p>Returns:</p> Type Description <code>set[LightAction]</code> <p>Set[Action]: A set of possible actions.</p> <p>Raises:</p> Type Description <code>MethodNotImplementedError</code> <p>If the method is not implemented.</p> Source code in <code>src/seahorse/game/game_state.py</code> <pre><code>@abstractmethod\ndef generate_possible_light_actions(self) -&gt; set[LightAction]:\n    \"\"\"\n    Generates a set of all possible actions from this game state.\n\n    Returns:\n        Set[Action]: A set of possible actions.\n\n    Raises:\n        MethodNotImplementedError: If the method is not implemented.\n    \"\"\"\n    raise MethodNotImplementedError()\n</code></pre>"},{"location":"reference/seahorse/game/game_state/#seahorse.game.game_state.GameState.get_next_player","title":"<code>get_next_player()</code>","text":"<p>Returns the next player.</p> <p>Returns:</p> Name Type Description <code>Player</code> <code>Player</code> <p>The next player.</p> Source code in <code>src/seahorse/game/game_state.py</code> <pre><code>def get_next_player(self) -&gt; Player:\n    \"\"\"\n    Returns the next player.\n\n    Returns:\n        Player: The next player.\n    \"\"\"\n    return self.next_player\n</code></pre>"},{"location":"reference/seahorse/game/game_state/#seahorse.game.game_state.GameState.get_player_score","title":"<code>get_player_score(player)</code>","text":"<p>Gets a player's score.</p> <p>Parameters:</p> Name Type Description Default <code>player</code> <code>Player</code> <p>The player.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The score.</p> Source code in <code>src/seahorse/game/game_state.py</code> <pre><code>def get_player_score(self, player: Player) -&gt; float:\n    \"\"\"\n    Gets a player's score.\n\n    Args:\n        player (Player): The player.\n\n    Returns:\n        float: The score.\n    \"\"\"\n    return self.scores[player.get_id()]\n</code></pre>"},{"location":"reference/seahorse/game/game_state/#seahorse.game.game_state.GameState.get_players","title":"<code>get_players()</code>","text":"<p>Returns the list of players.</p> <p>Returns:</p> Type Description <code>list[Player]</code> <p>List[Player]: The list of players.</p> Source code in <code>src/seahorse/game/game_state.py</code> <pre><code>def get_players(self) -&gt; list[Player]:\n    \"\"\"\n    Returns the list of players.\n\n    Returns:\n        List[Player]: The list of players.\n    \"\"\"\n    return self.players\n</code></pre>"},{"location":"reference/seahorse/game/game_state/#seahorse.game.game_state.GameState.get_possible_heavy_actions","title":"<code>get_possible_heavy_actions()</code>","text":"<p>Returns a copy of the possible heavy actions from this state. The first call triggers the <code>generate_possible_heavy_actions</code> method.</p> <p>Returns:</p> Type Description <code>frozenset[HeavyAction]</code> <p>FrozenSet[Action]: The possible actions.</p> Source code in <code>src/seahorse/game/game_state.py</code> <pre><code>def get_possible_heavy_actions(self) -&gt; frozenset[HeavyAction]:\n    \"\"\"\n    Returns a copy of the possible heavy actions from this state.\n    The first call triggers the `generate_possible_heavy_actions` method.\n\n    Returns:\n        FrozenSet[Action]: The possible actions.\n    \"\"\"\n    # Lazy loading\n    if self.is_done():\n        return frozenset()\n    if self._possible_heavy_actions is None:\n        self._possible_heavy_actions = frozenset(self.generate_possible_heavy_actions())\n    return self._possible_heavy_actions\n</code></pre>"},{"location":"reference/seahorse/game/game_state/#seahorse.game.game_state.GameState.get_possible_light_actions","title":"<code>get_possible_light_actions()</code>","text":"<p>Returns a copy of the possible light actions from this state. The first call triggers the <code>generate_possible_light_actions</code> method.</p> <p>Returns:</p> Type Description <code>frozenset[LightAction]</code> <p>FrozenSet[LightAction]: The possible actions.</p> Source code in <code>src/seahorse/game/game_state.py</code> <pre><code>def get_possible_light_actions(self) -&gt; frozenset[LightAction]:\n    \"\"\"\n    Returns a copy of the possible light actions from this state.\n    The first call triggers the `generate_possible_light_actions` method.\n\n    Returns:\n        FrozenSet[LightAction]: The possible actions.\n    \"\"\"\n    # Lazy loading\n    if self.is_done():\n        return frozenset()\n    if self._possible_light_actions is None:\n        self._possible_light_actions = frozenset(self.generate_possible_light_actions())\n    return self._possible_light_actions\n</code></pre>"},{"location":"reference/seahorse/game/game_state/#seahorse.game.game_state.GameState.get_rep","title":"<code>get_rep()</code>","text":"<p>Returns the representation of the game.</p> <p>Returns:</p> Name Type Description <code>Representation</code> <code>Representation</code> <p>The game representation.</p> Source code in <code>src/seahorse/game/game_state.py</code> <pre><code>def get_rep(self) -&gt; Representation:\n    \"\"\"\n    Returns the representation of the game.\n\n    Returns:\n        Representation: The game representation.\n    \"\"\"\n    return self.rep\n</code></pre>"},{"location":"reference/seahorse/game/game_state/#seahorse.game.game_state.GameState.get_scores","title":"<code>get_scores()</code>","text":"<p>Returns the scores.</p> <p>Returns:</p> Name Type Description <code>Dict</code> <code>dict[int, float]</code> <p>The player ID to score mapping.</p> Source code in <code>src/seahorse/game/game_state.py</code> <pre><code>def get_scores(self) -&gt; dict[int, float]:\n    \"\"\"\n    Returns the scores.\n\n    Returns:\n        Dict: The player ID to score mapping.\n    \"\"\"\n    return self.scores\n</code></pre>"},{"location":"reference/seahorse/game/game_state/#seahorse.game.game_state.GameState.is_done","title":"<code>is_done()</code>  <code>abstractmethod</code>","text":"<p>Indicates if the current GameState is final.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the state is final, False otherwise.</p> <p>Raises:</p> Type Description <code>MethodNotImplementedError</code> <p>If the method is not implemented.</p> Source code in <code>src/seahorse/game/game_state.py</code> <pre><code>@abstractmethod\ndef is_done(self) -&gt; bool:\n    \"\"\"\n    Indicates if the current GameState is final.\n\n    Returns:\n        bool: True if the state is final, False otherwise.\n\n    Raises:\n        MethodNotImplementedError: If the method is not implemented.\n    \"\"\"\n    raise MethodNotImplementedError()\n</code></pre>"},{"location":"reference/seahorse/game/heavy_action/","title":"Heavy action","text":""},{"location":"reference/seahorse/game/heavy_action/#seahorse.game.heavy_action.HeavyAction","title":"<code>HeavyAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>A class representing an action in the game.</p> <p>Attributes:</p> Name Type Description <code>past_gs</code> <code>GameState</code> <p>The past game state.</p> <code>new_gs</code> <code>GameState</code> <p>The new game state.</p> Source code in <code>src/seahorse/game/heavy_action.py</code> <pre><code>class HeavyAction(Action):\n    \"\"\"\n    A class representing an action in the game.\n\n    Attributes:\n        past_gs (GameState): The past game state.\n        new_gs (GameState): The new game state.\n    \"\"\"\n\n    def __init__(self, current_game_state: GameState, next_game_state: GameState) -&gt; None:\n        \"\"\"\n        Initializes a new instance of the Action class.\n\n        Args:\n            past_gs (GameState): The past game state.\n            new_gs (GameState): The new game state.\n        \"\"\"\n        self.current_game_state = current_game_state\n        self.next_game_state = next_game_state\n\n    def get_current_game_state(self) -&gt; GameState:\n        \"\"\"\n        Returns the past game state.\n\n        Returns:\n            GameState: The past game state.\n        \"\"\"\n        return self.current_game_state\n\n    def get_next_game_state(self) -&gt; GameState:\n        \"\"\"\n        Returns the new game state.\n\n        Returns:\n            GameState: The new game state.\n        \"\"\"\n        return self.next_game_state\n\n    def get_heavy_action(self, *_) -&gt; HeavyAction:\n        \"\"\"\n        Returns the heavy action.\n\n        Returns:\n            HeavyAction: The heavy action.\n        \"\"\"\n        return self\n\n    def __hash__(self) -&gt; int:\n        return hash((hash(self.get_next_game_state()), hash(self.get_current_game_state())))\n\n    def __eq__(self, value: object) -&gt; bool:\n        return hash(self) == hash(value)\n\n    def __str__(self) -&gt; str:\n        return \"From:\\n\" + self.get_current_game_state().get_rep().__str__() + \"\\nto:\\n\" + self.get_next_game_state().get_rep().__str__()\n\n    def to_json(self) -&gt; dict:\n        return self.__dict__\n</code></pre>"},{"location":"reference/seahorse/game/heavy_action/#seahorse.game.heavy_action.HeavyAction.__init__","title":"<code>__init__(current_game_state, next_game_state)</code>","text":"<p>Initializes a new instance of the Action class.</p> <p>Parameters:</p> Name Type Description Default <code>past_gs</code> <code>GameState</code> <p>The past game state.</p> required <code>new_gs</code> <code>GameState</code> <p>The new game state.</p> required Source code in <code>src/seahorse/game/heavy_action.py</code> <pre><code>def __init__(self, current_game_state: GameState, next_game_state: GameState) -&gt; None:\n    \"\"\"\n    Initializes a new instance of the Action class.\n\n    Args:\n        past_gs (GameState): The past game state.\n        new_gs (GameState): The new game state.\n    \"\"\"\n    self.current_game_state = current_game_state\n    self.next_game_state = next_game_state\n</code></pre>"},{"location":"reference/seahorse/game/heavy_action/#seahorse.game.heavy_action.HeavyAction.get_current_game_state","title":"<code>get_current_game_state()</code>","text":"<p>Returns the past game state.</p> <p>Returns:</p> Name Type Description <code>GameState</code> <code>GameState</code> <p>The past game state.</p> Source code in <code>src/seahorse/game/heavy_action.py</code> <pre><code>def get_current_game_state(self) -&gt; GameState:\n    \"\"\"\n    Returns the past game state.\n\n    Returns:\n        GameState: The past game state.\n    \"\"\"\n    return self.current_game_state\n</code></pre>"},{"location":"reference/seahorse/game/heavy_action/#seahorse.game.heavy_action.HeavyAction.get_heavy_action","title":"<code>get_heavy_action(*_)</code>","text":"<p>Returns the heavy action.</p> <p>Returns:</p> Name Type Description <code>HeavyAction</code> <code>HeavyAction</code> <p>The heavy action.</p> Source code in <code>src/seahorse/game/heavy_action.py</code> <pre><code>def get_heavy_action(self, *_) -&gt; HeavyAction:\n    \"\"\"\n    Returns the heavy action.\n\n    Returns:\n        HeavyAction: The heavy action.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/seahorse/game/heavy_action/#seahorse.game.heavy_action.HeavyAction.get_next_game_state","title":"<code>get_next_game_state()</code>","text":"<p>Returns the new game state.</p> <p>Returns:</p> Name Type Description <code>GameState</code> <code>GameState</code> <p>The new game state.</p> Source code in <code>src/seahorse/game/heavy_action.py</code> <pre><code>def get_next_game_state(self) -&gt; GameState:\n    \"\"\"\n    Returns the new game state.\n\n    Returns:\n        GameState: The new game state.\n    \"\"\"\n    return self.next_game_state\n</code></pre>"},{"location":"reference/seahorse/game/io_stream/","title":"Io stream","text":""},{"location":"reference/seahorse/game/io_stream/#seahorse.game.io_stream.EventMaster","title":"<code>EventMaster</code>","text":"<p>Singleton for emitting events</p> <p>Attributes:</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>when trying to initialize more than once</p> Source code in <code>src/seahorse/game/io_stream.py</code> <pre><code>class EventMaster:\n    \"\"\"\n    Singleton for emitting events\n\n    Attributes:\n\n\n    Raises:\n        NotImplementedError: when trying to initialize more than once\n\n    \"\"\"\n\n    __instance = None\n\n    @staticmethod\n    def get_instance(game_state:type=Serializable,port: int = 8080,hostname: str=\"localhost\") -&gt; EventMaster:\n        \"\"\"Gets the instance object\n\n        Args:\n            n_clients (int, optional): the number of clients the instance is supposed to be listening,\n                                       *ignored* if already initialized. Defaults to 1.\n            game_state : class of a game state\n            port (int, optional): the port to use. Defaults to 8080.\n\n        Returns:\n            object: _description_\n        \"\"\"\n        if EventMaster.__instance is None:\n            EventMaster(game_state=game_state, port=port, hostname=hostname)\n        return EventMaster.__instance\n\n    def __init__(self,game_state,port,hostname):\n        if EventMaster.__instance is not None:\n            msg = \"Trying to initialize multiple instances of EventMaster, \\\n                this is forbidden to avoid side-effects.\\n Call EventMaster.get_instance() instead.\"\n            raise NotImplementedError(msg)\n        else:\n            # Initializing attributes\n            self.expected_clients = 0\n            self.__n_clients_connected = 0\n            self.__identified_clients = {}\n            self.__open_sessions = set()\n            self.__ident2sid = {}\n            self.__sid2ident = {}\n            self.__events = {}\n            self.__game_state = game_state\n            self.port = port\n            self.hostname = hostname\n\n            # Standard python-socketio server\n            self.sio = socketio.AsyncServer(async_mode=\"aiohttp\", async_handlers=True,\n                                            cors_allowed_origins=\"*\", ping_timeout=1e6)\n            self.app = web.Application()\n\n            # Starting asyncio stuff\n            self.event_loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(self.event_loop)\n\n            # Attaching the app\n            self.sio.attach(self.app)\n\n            self.runner = web.AppRunner(self.app)\n\n            # Shutdown callback\n            async def on_shutdown(_):\n                for x in list(self.__open_sessions):\n                    if x in self.__open_sessions:\n                        await self.sio.disconnect(x)\n\n            self.app.on_shutdown.append(on_shutdown)\n\n            @self.sio.event()\n            def connect(sid, *_):\n                \"\"\"\n                    Handling incoming connections\n                \"\"\"\n                self.__open_sessions.add(sid)\n                self.__n_clients_connected += 1\n                logger.info(f\"Waiting for listeners {self.__n_clients_connected} \\\n                            out of {self.expected_clients} are connected.\")\n\n            @self.sio.event\n            def disconnect(sid):\n                logger.warning(f\"Lost connection: {sid}\")\n                self.__n_clients_connected -= 1\n                self.__open_sessions.remove(sid)\n                if sid in self.__sid2ident.keys() and self.__sid2ident[sid] in self.__identified_clients:\n                    logger.warning(f\"Client identified as {self.__sid2ident[sid]} was lost.\")\n                    del self.__identified_clients[self.__sid2ident[sid]]\n\n            @self.sio.on(\"*\")\n            async def catch_all(event,sid,data):\n                self.__events[sid] = self.__events.get(sid,{})\n                self.__events[sid][event] = self.__events[sid].get(event,deque())\n                self.__events[sid][event].appendleft((time.time(),data))\n\n            @self.sio.on(\"action\")\n            async def handle_play(sid,data):\n                # TODO : cope with race condition \"action\" before \"identify\"\n                try:\n                    self.__identified_clients[self.__sid2ident[sid]][\"incoming\"].appendleft(data)\n                # Plainly throw away packets that belong to disconnected clients\n                except KeyError:\n                    pass\n\n            @self.sio.on(\"identify\")\n            async def handle_identify(sid,data):\n                logger.info(\"Identifying a listener\")\n                logger.info(json.loads(data).get(\"identifier\",0))\n                logger.debug(f\"Deserialized data {json.loads(data)}\")\n                data = json.loads(data)\n\n                # TODO check presence of \"id\" in data\n                idf = data.get(\"identifier\",0)\n                reg = r\"^\"+idf+r\"(_duplicate_[0-9]+$|$)\"\n                if list(filter(lambda x:re.search(reg,x),self.__ident2sid.keys())):\n                    logger.warning(\"Two clients are using the same identifier, one of those will be ignored.\")\n                    idf = idf+\"_duplicate_\"+str(time.time())\n\n                self.__ident2sid[idf]=sid\n                self.__sid2ident[sid]=idf\n                self.__identified_clients[idf]={\"sid\":sid,\"id\":data.get(\"wrapped_id\",None),\"incoming\":deque(),\"attached\":False}\n\n\n            # Setting the singleton instance\n            EventMaster.__instance = self\n\n    async def wait_for_next_play(self,sid:int,players:list) -&gt; Action:\n        \"\"\"Waiting for the next play action, this function is blocking\n\n        Args:\n            sid (int): sid corresponding to the player to wait for\n            players (list): the list of players\n\n        Returns:\n            Action: returns the received action\n        \"\"\"\n        # TODO revise sanity checks to avoid critical errors\n        logger.info(f\"Waiting for next play from {self.__sid2ident[sid]}\")\n        while not len(self.__identified_clients[self.__sid2ident[sid]][\"incoming\"]):\n            await asyncio.sleep(.1)\n        logger.info(\"Action received\")\n        action = json.loads(self.__identified_clients[self.__sid2ident[sid]][\"incoming\"].pop())\n        next_player_id = int(action[\"next_game_state\"][\"next_player\"][\"id\"])\n        next_player = next(iter(list(filter(lambda p:p.id==next_player_id,players))))\n\n        past_gs = self.__game_state.from_json(json.dumps(action[\"current_game_state\"]))\n        past_gs.players = players\n        new_gs = self.__game_state.from_json(json.dumps(action[\"next_game_state\"]),next_player=next_player)\n        new_gs.players = players\n\n\n        return HeavyAction(past_gs,new_gs)\n\n    async def wait_for_event(self,sid:int,label:str,*,flush_until:float | None=None) -&gt; Coroutine:\n        \"\"\"Waits for an aribtrary event emitted by the connection identified by `sid`\n           and labeled with `label`.\n           One might want to ignore all events before a particular timestamp given in `flush_until`\n\n        Args:\n            sid (int): a socketio connexion identifier\n            label (str): the event to wait for\n            flush_until (float, optional): The timestamp treshold. Defaults to None.\n\n        Returns:\n            Coroutine: a promise yielding the data associated to the event\n        \"\"\"\n        while not len(self.__events.get(sid,{}).get(label,[])):\n            await asyncio.sleep(.1)\n        ts,data = self.__events[sid][label].pop()\n\n        if (not flush_until) or ts&gt;=flush_until:\n            return data\n        else :\n            await self.wait_for_event(sid,label,flush_until=flush_until)\n\n    async def wait_for_identified_client(self,name:str,local_id:int) -&gt; str:\n        \"\"\" Waits for an identified client (a player typically)\n\n        Args:\n            name (str): the name of the remote client\n        Returns:\n            str: the client sid\n        \"\"\"\n        reg = r\"^\"+name+r\"([0-9]+$|$)\"\n        def unattached_match(x):\n            return re.search(reg, x) and not self.__identified_clients.get(x)[\"attached\"]\n        matching_names = list(filter(unattached_match,self.__ident2sid.keys()))\n        while not matching_names:\n            await asyncio.sleep(.1)\n            matching_names = list(filter(unattached_match,self.__ident2sid.keys()))\n\n        cl = self.__identified_clients.get(matching_names[0])\n        self.__identified_clients[matching_names[0]][\"attached\"] = True\n\n        await self.sio.emit(\"update_id\",json.dumps({\"new_id\":local_id}),to=cl[\"sid\"])\n        return cl\n\n    def start(self, task: Callable[[None], None], listeners: list[EventSlave]) -&gt; None:\n        \"\"\"\n            This method is blocking.\n\n            Starts an emitting sequence and runs a tasks that embeds\n            calls to `EventMaster.__instance.sio.emit()`\n\n            The game is starting when for all `EventSlave` in `listeners`, the `.listen()` future is fulfilled.\n\n            If `len(listeners)==0` the EventMaster emits events in the void.\n\n            Args:\n                task (Callable[[None],None]): task calling `EventMaster.sio.emit()`\n        \"\"\"\n        slaves = list(filter(lambda x:isinstance(x,EventSlave),listeners))\n        self.expected_clients = len(slaves)\n\n        # Sets the runner up and starts the tcp server\n        self.event_loop.run_until_complete(self.runner.setup())\n        site = web.TCPSite(self.runner, self.hostname, self.port)\n        self.event_loop.run_until_complete(site.start())\n\n        async def stop(task):\n            # Waiting for all listeners to connect\n            logger.info(f\"Waiting for listeners {self.__n_clients_connected} \"\n                        f\"out of {self.expected_clients} are connected.\")\n            for x in slaves:\n                await x.listen(master_address=f\"http://{self.hostname}:{self.port!s}\", keep_alive=False)\n\n            # Launching the task\n            logger.info(\"Starting match\")\n            task_future = self.sio.start_background_task(task)\n\n            # Await the game task completion\n            try:\n                await task_future\n            except asyncio.CancelledError:\n                logger.warning(\"Game task was cancelled.\")\n\n            # Close listeners connection\n            for x in slaves:\n                await x.close_connection()\n\n            # Explicitly cancel any remaining tasks related to disconnected clients\n            # logger.info(\"Canceling pending tasks related to disconnected clients.\")\n            all_pending_tasks = [task for task in asyncio.all_tasks() if task is not asyncio.current_task()]\n            for pending_task in all_pending_tasks:\n                try:\n                    pending_task.cancel()\n                except asyncio.CancelledError:\n                    pass\n\n            # Cleanup runner to release socket\n            await self.runner.cleanup()\n\n        # Blocking call to the procedure\n        self.event_loop.run_until_complete(stop(task))\n</code></pre>"},{"location":"reference/seahorse/game/io_stream/#seahorse.game.io_stream.EventMaster.__init__","title":"<code>__init__(game_state, port, hostname)</code>","text":"Source code in <code>src/seahorse/game/io_stream.py</code> <pre><code>def __init__(self,game_state,port,hostname):\n    if EventMaster.__instance is not None:\n        msg = \"Trying to initialize multiple instances of EventMaster, \\\n            this is forbidden to avoid side-effects.\\n Call EventMaster.get_instance() instead.\"\n        raise NotImplementedError(msg)\n    else:\n        # Initializing attributes\n        self.expected_clients = 0\n        self.__n_clients_connected = 0\n        self.__identified_clients = {}\n        self.__open_sessions = set()\n        self.__ident2sid = {}\n        self.__sid2ident = {}\n        self.__events = {}\n        self.__game_state = game_state\n        self.port = port\n        self.hostname = hostname\n\n        # Standard python-socketio server\n        self.sio = socketio.AsyncServer(async_mode=\"aiohttp\", async_handlers=True,\n                                        cors_allowed_origins=\"*\", ping_timeout=1e6)\n        self.app = web.Application()\n\n        # Starting asyncio stuff\n        self.event_loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(self.event_loop)\n\n        # Attaching the app\n        self.sio.attach(self.app)\n\n        self.runner = web.AppRunner(self.app)\n\n        # Shutdown callback\n        async def on_shutdown(_):\n            for x in list(self.__open_sessions):\n                if x in self.__open_sessions:\n                    await self.sio.disconnect(x)\n\n        self.app.on_shutdown.append(on_shutdown)\n\n        @self.sio.event()\n        def connect(sid, *_):\n            \"\"\"\n                Handling incoming connections\n            \"\"\"\n            self.__open_sessions.add(sid)\n            self.__n_clients_connected += 1\n            logger.info(f\"Waiting for listeners {self.__n_clients_connected} \\\n                        out of {self.expected_clients} are connected.\")\n\n        @self.sio.event\n        def disconnect(sid):\n            logger.warning(f\"Lost connection: {sid}\")\n            self.__n_clients_connected -= 1\n            self.__open_sessions.remove(sid)\n            if sid in self.__sid2ident.keys() and self.__sid2ident[sid] in self.__identified_clients:\n                logger.warning(f\"Client identified as {self.__sid2ident[sid]} was lost.\")\n                del self.__identified_clients[self.__sid2ident[sid]]\n\n        @self.sio.on(\"*\")\n        async def catch_all(event,sid,data):\n            self.__events[sid] = self.__events.get(sid,{})\n            self.__events[sid][event] = self.__events[sid].get(event,deque())\n            self.__events[sid][event].appendleft((time.time(),data))\n\n        @self.sio.on(\"action\")\n        async def handle_play(sid,data):\n            # TODO : cope with race condition \"action\" before \"identify\"\n            try:\n                self.__identified_clients[self.__sid2ident[sid]][\"incoming\"].appendleft(data)\n            # Plainly throw away packets that belong to disconnected clients\n            except KeyError:\n                pass\n\n        @self.sio.on(\"identify\")\n        async def handle_identify(sid,data):\n            logger.info(\"Identifying a listener\")\n            logger.info(json.loads(data).get(\"identifier\",0))\n            logger.debug(f\"Deserialized data {json.loads(data)}\")\n            data = json.loads(data)\n\n            # TODO check presence of \"id\" in data\n            idf = data.get(\"identifier\",0)\n            reg = r\"^\"+idf+r\"(_duplicate_[0-9]+$|$)\"\n            if list(filter(lambda x:re.search(reg,x),self.__ident2sid.keys())):\n                logger.warning(\"Two clients are using the same identifier, one of those will be ignored.\")\n                idf = idf+\"_duplicate_\"+str(time.time())\n\n            self.__ident2sid[idf]=sid\n            self.__sid2ident[sid]=idf\n            self.__identified_clients[idf]={\"sid\":sid,\"id\":data.get(\"wrapped_id\",None),\"incoming\":deque(),\"attached\":False}\n\n\n        # Setting the singleton instance\n        EventMaster.__instance = self\n</code></pre>"},{"location":"reference/seahorse/game/io_stream/#seahorse.game.io_stream.EventMaster.get_instance","title":"<code>get_instance(game_state=Serializable, port=8080, hostname='localhost')</code>  <code>staticmethod</code>","text":"<p>Gets the instance object</p> <p>Parameters:</p> Name Type Description Default <code>n_clients</code> <code>int</code> <p>the number of clients the instance is supposed to be listening,                        ignored if already initialized. Defaults to 1.</p> required <code>game_state</code> <p>class of a game state</p> <code>Serializable</code> <code>port</code> <code>int</code> <p>the port to use. Defaults to 8080.</p> <code>8080</code> <p>Returns:</p> Name Type Description <code>object</code> <code>EventMaster</code> <p>description</p> Source code in <code>src/seahorse/game/io_stream.py</code> <pre><code>@staticmethod\ndef get_instance(game_state:type=Serializable,port: int = 8080,hostname: str=\"localhost\") -&gt; EventMaster:\n    \"\"\"Gets the instance object\n\n    Args:\n        n_clients (int, optional): the number of clients the instance is supposed to be listening,\n                                   *ignored* if already initialized. Defaults to 1.\n        game_state : class of a game state\n        port (int, optional): the port to use. Defaults to 8080.\n\n    Returns:\n        object: _description_\n    \"\"\"\n    if EventMaster.__instance is None:\n        EventMaster(game_state=game_state, port=port, hostname=hostname)\n    return EventMaster.__instance\n</code></pre>"},{"location":"reference/seahorse/game/io_stream/#seahorse.game.io_stream.EventMaster.start","title":"<code>start(task, listeners)</code>","text":"<p>This method is blocking.</p> <p>Starts an emitting sequence and runs a tasks that embeds calls to <code>EventMaster.__instance.sio.emit()</code></p> <p>The game is starting when for all <code>EventSlave</code> in <code>listeners</code>, the <code>.listen()</code> future is fulfilled.</p> <p>If <code>len(listeners)==0</code> the EventMaster emits events in the void.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Callable[[None], None]</code> <p>task calling <code>EventMaster.sio.emit()</code></p> required Source code in <code>src/seahorse/game/io_stream.py</code> <pre><code>def start(self, task: Callable[[None], None], listeners: list[EventSlave]) -&gt; None:\n    \"\"\"\n        This method is blocking.\n\n        Starts an emitting sequence and runs a tasks that embeds\n        calls to `EventMaster.__instance.sio.emit()`\n\n        The game is starting when for all `EventSlave` in `listeners`, the `.listen()` future is fulfilled.\n\n        If `len(listeners)==0` the EventMaster emits events in the void.\n\n        Args:\n            task (Callable[[None],None]): task calling `EventMaster.sio.emit()`\n    \"\"\"\n    slaves = list(filter(lambda x:isinstance(x,EventSlave),listeners))\n    self.expected_clients = len(slaves)\n\n    # Sets the runner up and starts the tcp server\n    self.event_loop.run_until_complete(self.runner.setup())\n    site = web.TCPSite(self.runner, self.hostname, self.port)\n    self.event_loop.run_until_complete(site.start())\n\n    async def stop(task):\n        # Waiting for all listeners to connect\n        logger.info(f\"Waiting for listeners {self.__n_clients_connected} \"\n                    f\"out of {self.expected_clients} are connected.\")\n        for x in slaves:\n            await x.listen(master_address=f\"http://{self.hostname}:{self.port!s}\", keep_alive=False)\n\n        # Launching the task\n        logger.info(\"Starting match\")\n        task_future = self.sio.start_background_task(task)\n\n        # Await the game task completion\n        try:\n            await task_future\n        except asyncio.CancelledError:\n            logger.warning(\"Game task was cancelled.\")\n\n        # Close listeners connection\n        for x in slaves:\n            await x.close_connection()\n\n        # Explicitly cancel any remaining tasks related to disconnected clients\n        # logger.info(\"Canceling pending tasks related to disconnected clients.\")\n        all_pending_tasks = [task for task in asyncio.all_tasks() if task is not asyncio.current_task()]\n        for pending_task in all_pending_tasks:\n            try:\n                pending_task.cancel()\n            except asyncio.CancelledError:\n                pass\n\n        # Cleanup runner to release socket\n        await self.runner.cleanup()\n\n    # Blocking call to the procedure\n    self.event_loop.run_until_complete(stop(task))\n</code></pre>"},{"location":"reference/seahorse/game/io_stream/#seahorse.game.io_stream.EventMaster.wait_for_event","title":"<code>wait_for_event(sid, label, *, flush_until=None)</code>  <code>async</code>","text":"<p>Waits for an aribtrary event emitted by the connection identified by <code>sid</code>    and labeled with <code>label</code>.    One might want to ignore all events before a particular timestamp given in <code>flush_until</code></p> <p>Parameters:</p> Name Type Description Default <code>sid</code> <code>int</code> <p>a socketio connexion identifier</p> required <code>label</code> <code>str</code> <p>the event to wait for</p> required <code>flush_until</code> <code>float</code> <p>The timestamp treshold. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Coroutine</code> <code>Coroutine</code> <p>a promise yielding the data associated to the event</p> Source code in <code>src/seahorse/game/io_stream.py</code> <pre><code>async def wait_for_event(self,sid:int,label:str,*,flush_until:float | None=None) -&gt; Coroutine:\n    \"\"\"Waits for an aribtrary event emitted by the connection identified by `sid`\n       and labeled with `label`.\n       One might want to ignore all events before a particular timestamp given in `flush_until`\n\n    Args:\n        sid (int): a socketio connexion identifier\n        label (str): the event to wait for\n        flush_until (float, optional): The timestamp treshold. Defaults to None.\n\n    Returns:\n        Coroutine: a promise yielding the data associated to the event\n    \"\"\"\n    while not len(self.__events.get(sid,{}).get(label,[])):\n        await asyncio.sleep(.1)\n    ts,data = self.__events[sid][label].pop()\n\n    if (not flush_until) or ts&gt;=flush_until:\n        return data\n    else :\n        await self.wait_for_event(sid,label,flush_until=flush_until)\n</code></pre>"},{"location":"reference/seahorse/game/io_stream/#seahorse.game.io_stream.EventMaster.wait_for_identified_client","title":"<code>wait_for_identified_client(name, local_id)</code>  <code>async</code>","text":"<p>Waits for an identified client (a player typically)</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the remote client</p> required <p>Returns:     str: the client sid</p> Source code in <code>src/seahorse/game/io_stream.py</code> <pre><code>async def wait_for_identified_client(self,name:str,local_id:int) -&gt; str:\n    \"\"\" Waits for an identified client (a player typically)\n\n    Args:\n        name (str): the name of the remote client\n    Returns:\n        str: the client sid\n    \"\"\"\n    reg = r\"^\"+name+r\"([0-9]+$|$)\"\n    def unattached_match(x):\n        return re.search(reg, x) and not self.__identified_clients.get(x)[\"attached\"]\n    matching_names = list(filter(unattached_match,self.__ident2sid.keys()))\n    while not matching_names:\n        await asyncio.sleep(.1)\n        matching_names = list(filter(unattached_match,self.__ident2sid.keys()))\n\n    cl = self.__identified_clients.get(matching_names[0])\n    self.__identified_clients[matching_names[0]][\"attached\"] = True\n\n    await self.sio.emit(\"update_id\",json.dumps({\"new_id\":local_id}),to=cl[\"sid\"])\n    return cl\n</code></pre>"},{"location":"reference/seahorse/game/io_stream/#seahorse.game.io_stream.EventMaster.wait_for_next_play","title":"<code>wait_for_next_play(sid, players)</code>  <code>async</code>","text":"<p>Waiting for the next play action, this function is blocking</p> <p>Parameters:</p> Name Type Description Default <code>sid</code> <code>int</code> <p>sid corresponding to the player to wait for</p> required <code>players</code> <code>list</code> <p>the list of players</p> required <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>returns the received action</p> Source code in <code>src/seahorse/game/io_stream.py</code> <pre><code>async def wait_for_next_play(self,sid:int,players:list) -&gt; Action:\n    \"\"\"Waiting for the next play action, this function is blocking\n\n    Args:\n        sid (int): sid corresponding to the player to wait for\n        players (list): the list of players\n\n    Returns:\n        Action: returns the received action\n    \"\"\"\n    # TODO revise sanity checks to avoid critical errors\n    logger.info(f\"Waiting for next play from {self.__sid2ident[sid]}\")\n    while not len(self.__identified_clients[self.__sid2ident[sid]][\"incoming\"]):\n        await asyncio.sleep(.1)\n    logger.info(\"Action received\")\n    action = json.loads(self.__identified_clients[self.__sid2ident[sid]][\"incoming\"].pop())\n    next_player_id = int(action[\"next_game_state\"][\"next_player\"][\"id\"])\n    next_player = next(iter(list(filter(lambda p:p.id==next_player_id,players))))\n\n    past_gs = self.__game_state.from_json(json.dumps(action[\"current_game_state\"]))\n    past_gs.players = players\n    new_gs = self.__game_state.from_json(json.dumps(action[\"next_game_state\"]),next_player=next_player)\n    new_gs.players = players\n\n\n    return HeavyAction(past_gs,new_gs)\n</code></pre>"},{"location":"reference/seahorse/game/io_stream/#seahorse.game.io_stream.EventSlave","title":"<code>EventSlave</code>","text":"Source code in <code>src/seahorse/game/io_stream.py</code> <pre><code>class EventSlave:\n\n    def activate(self,\n                 identifier:str | None = None,\n                 wrapped_id:int | None = None,\n                 *,\n                 disconnected_cb: Callable[[None],None] | None = None\n                 ) -&gt; None:\n        \"\"\"\n        Sets the listener up, binds handlers\n\n        Args:\n            identifier (str | None, optional): Must be a unique identifier. Defaults to None.\n            wrapped_id (int | None, optional): If the eventSlave is bound to an instance,\n                                               a python native id might be associated.\n                                               Defaults to None.\n        \"\"\"\n        self.sio = socketio.AsyncClient()\n        self.connected = False\n        self.identifier = identifier\n        self.wrapped_id = wrapped_id\n        self.disconnected_cb = disconnected_cb\n\n        @self.sio.event()\n        async def connect():\n            self.connected = True\n            if self.identifier is not None:\n                await self.sio.emit(\"identify\", json.dumps(self.__dict__,default=lambda _:\"_\"))\n\n        @self.sio.event\n        def disconnect():\n            self.connected = False\n\n\n    async def listen(self,master_address:str,*,keep_alive:bool) -&gt; None:\n        \"\"\"Fires up the listening process\n\n        Args:\n            master_address (str): the address to listen to\n            keep_alive (bool): in standalone mode, this should be `True` to keep the asyncio process alive.\n        \"\"\"\n        if not self.connected:\n            await self.sio.connect(master_address)\n        if keep_alive:\n            while self.connected:\n                await asyncio.sleep(.1)\n\n    async def close_connection(self) -&gt; None:\n        await asyncio.sleep(0.5)\n        if hasattr(self, \"connected\") and self.connected:\n            await self.sio.disconnect()\n            self.connected = False\n</code></pre>"},{"location":"reference/seahorse/game/io_stream/#seahorse.game.io_stream.EventSlave.activate","title":"<code>activate(identifier=None, wrapped_id=None, *, disconnected_cb=None)</code>","text":"<p>Sets the listener up, binds handlers</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str | None</code> <p>Must be a unique identifier. Defaults to None.</p> <code>None</code> <code>wrapped_id</code> <code>int | None</code> <p>If the eventSlave is bound to an instance,                                a python native id might be associated.                                Defaults to None.</p> <code>None</code> Source code in <code>src/seahorse/game/io_stream.py</code> <pre><code>def activate(self,\n             identifier:str | None = None,\n             wrapped_id:int | None = None,\n             *,\n             disconnected_cb: Callable[[None],None] | None = None\n             ) -&gt; None:\n    \"\"\"\n    Sets the listener up, binds handlers\n\n    Args:\n        identifier (str | None, optional): Must be a unique identifier. Defaults to None.\n        wrapped_id (int | None, optional): If the eventSlave is bound to an instance,\n                                           a python native id might be associated.\n                                           Defaults to None.\n    \"\"\"\n    self.sio = socketio.AsyncClient()\n    self.connected = False\n    self.identifier = identifier\n    self.wrapped_id = wrapped_id\n    self.disconnected_cb = disconnected_cb\n\n    @self.sio.event()\n    async def connect():\n        self.connected = True\n        if self.identifier is not None:\n            await self.sio.emit(\"identify\", json.dumps(self.__dict__,default=lambda _:\"_\"))\n\n    @self.sio.event\n    def disconnect():\n        self.connected = False\n</code></pre>"},{"location":"reference/seahorse/game/io_stream/#seahorse.game.io_stream.EventSlave.listen","title":"<code>listen(master_address, *, keep_alive)</code>  <code>async</code>","text":"<p>Fires up the listening process</p> <p>Parameters:</p> Name Type Description Default <code>master_address</code> <code>str</code> <p>the address to listen to</p> required <code>keep_alive</code> <code>bool</code> <p>in standalone mode, this should be <code>True</code> to keep the asyncio process alive.</p> required Source code in <code>src/seahorse/game/io_stream.py</code> <pre><code>async def listen(self,master_address:str,*,keep_alive:bool) -&gt; None:\n    \"\"\"Fires up the listening process\n\n    Args:\n        master_address (str): the address to listen to\n        keep_alive (bool): in standalone mode, this should be `True` to keep the asyncio process alive.\n    \"\"\"\n    if not self.connected:\n        await self.sio.connect(master_address)\n    if keep_alive:\n        while self.connected:\n            await asyncio.sleep(.1)\n</code></pre>"},{"location":"reference/seahorse/game/io_stream/#seahorse.game.io_stream.event_emitting","title":"<code>event_emitting(label)</code>","text":"<p>Decorator to also send the function's output trough listening socket connexions</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>the type of event to emit</p> required Source code in <code>src/seahorse/game/io_stream.py</code> <pre><code>def event_emitting(label:str):\n    \"\"\"Decorator to also send the function's output trough listening socket connexions\n\n    Args:\n        label (str): the type of event to emit\n    \"\"\"\n    def meta_wrapper(fun: Callable[[Any],Action]):\n        @functools.wraps(fun)\n        async def wrapper(self:EventSlave,*args,**kwargs):\n            out = fun(self,*args, **kwargs)\n            await self.sio.emit(label,json.dumps(out.to_json(),default=lambda x:x.to_json()))\n            return out\n\n        return wrapper\n\n    return meta_wrapper\n</code></pre>"},{"location":"reference/seahorse/game/io_stream/#seahorse.game.io_stream.remote_action","title":"<code>remote_action(label)</code>","text":"<p>Proxy decorator to override an expected local behavior with a distant one    The logic in decorated function is ignored Args:     label (str): the time of event to emit to trigger the distant logic</p> Source code in <code>src/seahorse/game/io_stream.py</code> <pre><code>def remote_action(label: str):\n    \"\"\"Proxy decorator to override an expected local behavior with a distant one\n       *The logic in decorated function is ignored*\n    Args:\n        label (str): the time of event to emit to trigger the distant logic\n    \"\"\"\n    def meta_wrapper(fun: Callable):\n        @functools.wraps(fun)\n        async def wrapper(self:EventSlave,current_state:GameState,*_,**kwargs):\n            await EventMaster.get_instance().sio.emit(label,json.dumps({**current_state.to_json(),**kwargs},\n                                                                       default=lambda x:x.to_json()),\n                                                                       to=self.sid)\n            out = await EventMaster.get_instance().wait_for_next_play(self.sid,current_state.players)\n            return out\n\n        return wrapper\n\n    return meta_wrapper\n</code></pre>"},{"location":"reference/seahorse/game/light_action/","title":"Light action","text":""},{"location":"reference/seahorse/game/light_action/#seahorse.game.light_action.LightAction","title":"<code>LightAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>A class representing an action in the game.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>dict</code> <p>The data of the light action.</p> Source code in <code>src/seahorse/game/light_action.py</code> <pre><code>class LightAction(Action):\n    \"\"\"\n    A class representing an action in the game.\n\n    Attributes:\n        data (dict): The data of the light action.\n    \"\"\"\n\n    def __init__(self, data: dict) -&gt; None:\n        \"\"\"\n        Initializes a new instance of the Action class.\n\n        Args: data (dict): The data of the light action.\n\n        \"\"\"\n        self.data = data\n\n\n    def get_heavy_action(self, game_state: GameState = None) -&gt; HeavyAction:\n        \"\"\"\n        Returns the heavy action.\n\n        Returns:\n            HeavyAction: The heavy action.\n        \"\"\"\n        if game_state is None:\n            raise NoGameStateProvidedError()\n\n        return HeavyAction(game_state, game_state.apply_action(self))\n\n\n    def __hash__(self) -&gt; int:\n        return hash(tuple(self.data.items()))\n\n    def __eq__(self, value: object) -&gt; bool:\n        return hash(self) == hash(value)\n\n    def __str__(self) -&gt; str:\n        return \"LightAction: \" + str(self.data)\n\n    def to_json(self) -&gt; dict:\n        return self.__dict__\n</code></pre>"},{"location":"reference/seahorse/game/light_action/#seahorse.game.light_action.LightAction.__init__","title":"<code>__init__(data)</code>","text":"<p>Initializes a new instance of the Action class.</p> <p>Args: data (dict): The data of the light action.</p> Source code in <code>src/seahorse/game/light_action.py</code> <pre><code>def __init__(self, data: dict) -&gt; None:\n    \"\"\"\n    Initializes a new instance of the Action class.\n\n    Args: data (dict): The data of the light action.\n\n    \"\"\"\n    self.data = data\n</code></pre>"},{"location":"reference/seahorse/game/light_action/#seahorse.game.light_action.LightAction.get_heavy_action","title":"<code>get_heavy_action(game_state=None)</code>","text":"<p>Returns the heavy action.</p> <p>Returns:</p> Name Type Description <code>HeavyAction</code> <code>HeavyAction</code> <p>The heavy action.</p> Source code in <code>src/seahorse/game/light_action.py</code> <pre><code>def get_heavy_action(self, game_state: GameState = None) -&gt; HeavyAction:\n    \"\"\"\n    Returns the heavy action.\n\n    Returns:\n        HeavyAction: The heavy action.\n    \"\"\"\n    if game_state is None:\n        raise NoGameStateProvidedError()\n\n    return HeavyAction(game_state, game_state.apply_action(self))\n</code></pre>"},{"location":"reference/seahorse/game/master/","title":"Master","text":""},{"location":"reference/seahorse/game/master/#seahorse.game.master.GameMaster","title":"<code>GameMaster</code>","text":"<p>A class representing the game master.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the game.</p> <code>initial_game_state</code> <code>GameState</code> <p>The initial state of the game.</p> <code>current_game_state</code> <code>GameState</code> <p>The current state of the game.</p> <code>players_iterator</code> <code>Iterable</code> <p>An iterable for the players, ordered according to the playing order. If a list is provided, a cyclic iterator is automatically built.</p> <code>log_level</code> <code>str</code> <p>The name of the log file.</p> Source code in <code>src/seahorse/game/master.py</code> <pre><code>class GameMaster:\n    \"\"\"\n    A class representing the game master.\n\n    Attributes:\n        name (str): The name of the game.\n        initial_game_state (GameState): The initial state of the game.\n        current_game_state (GameState): The current state of the game.\n        players_iterator (Iterable): An iterable for the players, ordered according\n            to the playing order. If a list is provided, a cyclic iterator is automatically built.\n        log_level (str): The name of the log file.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        initial_game_state: GameState,\n        players_iterator: Iterable[Player],\n        log_level: str = \"INFO\",\n        port: int =8080,\n        hostname: str =\"localhost\",\n        time_limit: int = 1e9,\n    ) -&gt; None:\n        \"\"\"\n        Initializes a new instance of the GameMaster class.\n\n        Args:\n            name (str): The name of the game.\n            initial_game_state (GameState): The initial state of the game.\n            players_iterator (Iterable[Player]): An iterable for the players, ordered according\n                to the playing order.\n            log_level (str): The name of the log file.\n        \"\"\"\n        self.timetol = 1e-1\n        self.name = name\n        self.current_game_state = initial_game_state\n        self.players = initial_game_state.players\n        self.remaining_time = {player.get_id(): time_limit for player in self.players}\n\n        player_names = [x.name for x in self.players]\n        if len(set(player_names))&lt;len(self.players):\n            logger.error(\"Multiple players have the same name this is not allowed.\")\n            logger.error(\"Please rename your players such that there is no duplicate in the following list: \")\n            logger.error(f\"{player_names}\")\n            raise PlayerDuplicateError()\n\n\n        self.log_level = log_level\n        self.players_iterator = cycle(players_iterator) if isinstance(players_iterator, list) else players_iterator\n        next(self.players_iterator)\n        self.emitter = EventMaster.get_instance(initial_game_state.__class__,port=port,hostname=hostname)\n        logger.remove()\n\n        from functools import partialmethod\n\n        if \"VERDICT\" not in logger._core.levels:\n            logger.level(\"VERDICT\", no=33, icon=\"x\", color=\"&lt;blue&gt;\")\n            logger.__class__.verdict = partialmethod(logger.__class__.log, \"VERDICT\")\n\n        logger.add(sys.stderr, level=log_level)\n\n    async def step(self) -&gt; GameState:\n        \"\"\"\n        Calls the next player move.\n\n        Returns:\n            GamseState : The new game_state.\n        \"\"\"\n        next_player = self.current_game_state.get_next_player()\n\n        possible_actions = self.current_game_state.get_possible_heavy_actions()\n\n        start = time.time()\n\n        logger.info(f\"time : {self.remaining_time[next_player.get_id()]}\")\n        if isinstance(next_player,EventSlave):\n            action = await next_player.play(self.current_game_state,\n                                            remaining_time=self.remaining_time[next_player.get_id()])\n        else:\n            action = next_player.play(self.current_game_state,\n                                      remaining_time=self.remaining_time[next_player.get_id()])\n        tstp = time.time()\n        self.remaining_time[next_player.get_id()] -= (tstp-start)\n        if self.remaining_time[next_player.get_id()] &lt; 0:\n            raise SeahorseTimeoutError()\n\n        action = action.get_heavy_action(self.current_game_state)\n        if action not in possible_actions:\n            raise ActionNotPermittedError()\n\n        return action.get_next_game_state()\n\n    async def play_game(self) -&gt; list[Player]:\n        \"\"\"\n        Play the game.\n\n        Returns:\n            Iterable[Player]: The winner(s) of the game.\n        \"\"\"\n        # Prepare the game state JSON and add remaining time info\n        play_payload = self.current_game_state.to_json()\n        play_payload[\"remaining_time\"] = self.remaining_time.copy()\n        await self.emitter.sio.emit(\n            \"play\",\n            json.dumps(play_payload, default=lambda x: x.to_json()),\n        )\n        id2player={}\n        for player in self.get_game_state().get_players() :\n            id2player[player.get_id()]=player.get_name()\n            logger.info(f\"Player : {player.get_name()} - {player.get_id()}\")\n        while not self.current_game_state.is_done():\n            try:\n                logger.info(f\"Player now playing : {self.get_game_state().get_next_player().get_name()} \"\n                            f\"- {self.get_game_state().get_next_player().get_id()}\")\n                self.current_game_state = await self.step()\n            except (ActionNotPermittedError,SeahorseTimeoutError,StopAndStartError) as e:\n                if isinstance(e,SeahorseTimeoutError):\n                    logger.error(f\"Time credit expired for player {self.current_game_state.get_next_player()}\")\n                elif isinstance(e,ActionNotPermittedError) :\n                    logger.error(f\"Action not permitted for player {self.current_game_state.get_next_player()}\")\n\n                temp_score = copy.copy(self.current_game_state.get_scores())\n                id_player_error = self.current_game_state.get_next_player().get_id()\n                other_player = next(iter([player.get_id() for player in self.current_game_state.get_players() if\n                                          player.get_id()!=id_player_error]))\n                temp_score[id_player_error] = -1e9\n                temp_score[other_player] = 1e9\n                for key in temp_score.keys():\n                    logger.info(f\"{id2player[key]}:{temp_score[key]}\")\n\n                for player in self.get_winner(looser_ids={id_player_error}) :\n                    logger.info(f\"Winner - {player.get_name()}\")\n\n                await self.emitter.sio.emit(\"done\",json.dumps({\n                    \"players\": [{\"id\":player.get_id(), \"name\":player.get_name()}\n                                for player in self.current_game_state.get_players()],\n                    \"scores\": self.get_scores(),\n                    \"custom_stats\": self.get_custom_stats(),\n                    \"winners_id\": [player.get_id() for player in self.get_winner()],\n                    \"status\": \"cancelled\",\n                }))\n\n                logger.verdict(f\"{self.current_game_state.get_next_player().get_name()} has been disqualified\")\n\n                return self.winner\n\n            logger.info(f\"Current game state: \\n{self.current_game_state.get_rep()}\")\n\n            # Prepare the game state JSON and add remaining time info\n            play_payload = self.current_game_state.to_json()\n            play_payload[\"remaining_time\"] = self.remaining_time.copy()\n            await self.emitter.sio.emit(\n                \"play\",\n                json.dumps(play_payload, default=lambda x: x.to_json()),\n            )\n\n        scores = self.get_scores()\n        for key in scores.keys():\n                logger.info(f\"{id2player[key]}:{(scores[key])}\")\n\n        for player in self.get_winner() :\n            logger.info(f\"Winner - {player.get_name()}\")\n\n        await self.emitter.sio.emit(\"done\",json.dumps({\n            \"players\": [{\"id\":player.get_id(), \"name\":player.get_name()}\n                        for player in self.current_game_state.get_players()],\n            \"scores\": self.get_scores(),\n            \"custom_stats\": self.get_custom_stats(),\n            \"winners_id\": [player.get_id() for player in self.get_winner()],\n            \"status\": \"done\",\n        }))\n        logger.verdict(f\"{','.join(w.get_name() for w in self.get_winner())} has won the game\")\n        return self.winner\n\n    def record_game(self, listeners:Optional[list[EventSlave]]=None) -&gt; None:\n        \"\"\"\n        Starts a game and broadcasts its successive states.\n        \"\"\"\n        self.emitter.start(self.play_game, self.players+(listeners if listeners else []))\n\n    def update_log(self) -&gt; None:\n        \"\"\"\n        Updates the log file.\n\n        Raises:\n            MethodNotImplementedError: If the method is not implemented.\n        \"\"\"\n        raise MethodNotImplementedError()\n\n    def get_name(self) -&gt; str:\n        \"\"\"\n        Returns:\n            str: The name of the game.\n        \"\"\"\n        return self.name\n\n    def get_game_state(self) -&gt; GameState:\n        \"\"\"\n        Returns:\n            GameState: The current game state.\n        \"\"\"\n        return self.current_game_state\n\n    def get_json_path(self) -&gt; str:\n        \"\"\"\n        Returns:\n            str: The path of the log file.\n        \"\"\"\n        return self.log_level\n\n    def get_winner(self, looser_ids: Container[int] | None = None) -&gt; list[Player]:\n        \"\"\"\n        Arguments:\n            looser_ids (Container[int], optional): The IDs of the players who lost the game.\n            If provided, the winners will be all players except these ones.\n        Returns:\n            Player: The winner(s) of the game.\n\n        \"\"\"\n        if not hasattr(self, \"winner\"):\n            if looser_ids is not None:\n                self.winner = [player for player in self.current_game_state.get_players()\n                               if player.get_id() not in looser_ids]\n            else:\n                self.winner = self.compute_winner()\n\n        return self.winner\n\n    def get_scores(self) -&gt; dict[int, float]:\n        \"\"\"\n        Returns:\n            Dict: The scores of the current state.\n        \"\"\"\n        return self.current_game_state.get_scores()\n\n    def get_custom_stats(self) -&gt; list[CustomStat]:\n        \"\"\"\n        Returns:\n            list[CustomState]: The custom statistics of the game.\n        \"\"\"\n        if not hasattr(self, \"custom_stats\"):\n            self.custom_stats = self.compute_custom_stats()\n        return self.custom_stats\n\n    def compute_custom_stats(self) -&gt; list[CustomStat]:\n        \"\"\"\n        Computes custom statistics for the game.\n        It should be overridden by subclasses to provide specific statistics.\n        It should use self.get_game_state() to access the current game state.\n        If should use the format :\n        [\n            {\"name\": \"stat_name_1\", \"value\": value_1, \"agent_id\": player_id_1},\n            {\"name\": \"stat_name_2\", \"value\": value_2, \"agent_id\": player_id_2},\n            ...\n        ]\n        Returns:\n            list[CustomStat]: A list of dictionaries containing custom statistics.\n        \"\"\"\n        return []\n\n    @abstractmethod\n    def compute_winner(self) -&gt; list[Player]:\n        \"\"\"\n        Computes the winner(s) of the game based on the current game state.\n\n        Raises:\n            MethodNotImplementedError: If the method is not implemented.\n\n        Returns:\n            Iterable[Player]: The list of player(s) who won the game.\n        \"\"\"\n        raise MethodNotImplementedError()\n</code></pre>"},{"location":"reference/seahorse/game/master/#seahorse.game.master.GameMaster.__init__","title":"<code>__init__(name, initial_game_state, players_iterator, log_level='INFO', port=8080, hostname='localhost', time_limit=1000000000.0)</code>","text":"<p>Initializes a new instance of the GameMaster class.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the game.</p> required <code>initial_game_state</code> <code>GameState</code> <p>The initial state of the game.</p> required <code>players_iterator</code> <code>Iterable[Player]</code> <p>An iterable for the players, ordered according to the playing order.</p> required <code>log_level</code> <code>str</code> <p>The name of the log file.</p> <code>'INFO'</code> Source code in <code>src/seahorse/game/master.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    initial_game_state: GameState,\n    players_iterator: Iterable[Player],\n    log_level: str = \"INFO\",\n    port: int =8080,\n    hostname: str =\"localhost\",\n    time_limit: int = 1e9,\n) -&gt; None:\n    \"\"\"\n    Initializes a new instance of the GameMaster class.\n\n    Args:\n        name (str): The name of the game.\n        initial_game_state (GameState): The initial state of the game.\n        players_iterator (Iterable[Player]): An iterable for the players, ordered according\n            to the playing order.\n        log_level (str): The name of the log file.\n    \"\"\"\n    self.timetol = 1e-1\n    self.name = name\n    self.current_game_state = initial_game_state\n    self.players = initial_game_state.players\n    self.remaining_time = {player.get_id(): time_limit for player in self.players}\n\n    player_names = [x.name for x in self.players]\n    if len(set(player_names))&lt;len(self.players):\n        logger.error(\"Multiple players have the same name this is not allowed.\")\n        logger.error(\"Please rename your players such that there is no duplicate in the following list: \")\n        logger.error(f\"{player_names}\")\n        raise PlayerDuplicateError()\n\n\n    self.log_level = log_level\n    self.players_iterator = cycle(players_iterator) if isinstance(players_iterator, list) else players_iterator\n    next(self.players_iterator)\n    self.emitter = EventMaster.get_instance(initial_game_state.__class__,port=port,hostname=hostname)\n    logger.remove()\n\n    from functools import partialmethod\n\n    if \"VERDICT\" not in logger._core.levels:\n        logger.level(\"VERDICT\", no=33, icon=\"x\", color=\"&lt;blue&gt;\")\n        logger.__class__.verdict = partialmethod(logger.__class__.log, \"VERDICT\")\n\n    logger.add(sys.stderr, level=log_level)\n</code></pre>"},{"location":"reference/seahorse/game/master/#seahorse.game.master.GameMaster.compute_custom_stats","title":"<code>compute_custom_stats()</code>","text":"<p>Computes custom statistics for the game. It should be overridden by subclasses to provide specific statistics. It should use self.get_game_state() to access the current game state. If should use the format : [     {\"name\": \"stat_name_1\", \"value\": value_1, \"agent_id\": player_id_1},     {\"name\": \"stat_name_2\", \"value\": value_2, \"agent_id\": player_id_2},     ... ] Returns:     list[CustomStat]: A list of dictionaries containing custom statistics.</p> Source code in <code>src/seahorse/game/master.py</code> <pre><code>def compute_custom_stats(self) -&gt; list[CustomStat]:\n    \"\"\"\n    Computes custom statistics for the game.\n    It should be overridden by subclasses to provide specific statistics.\n    It should use self.get_game_state() to access the current game state.\n    If should use the format :\n    [\n        {\"name\": \"stat_name_1\", \"value\": value_1, \"agent_id\": player_id_1},\n        {\"name\": \"stat_name_2\", \"value\": value_2, \"agent_id\": player_id_2},\n        ...\n    ]\n    Returns:\n        list[CustomStat]: A list of dictionaries containing custom statistics.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/seahorse/game/master/#seahorse.game.master.GameMaster.compute_winner","title":"<code>compute_winner()</code>  <code>abstractmethod</code>","text":"<p>Computes the winner(s) of the game based on the current game state.</p> <p>Raises:</p> Type Description <code>MethodNotImplementedError</code> <p>If the method is not implemented.</p> <p>Returns:</p> Type Description <code>list[Player]</code> <p>Iterable[Player]: The list of player(s) who won the game.</p> Source code in <code>src/seahorse/game/master.py</code> <pre><code>@abstractmethod\ndef compute_winner(self) -&gt; list[Player]:\n    \"\"\"\n    Computes the winner(s) of the game based on the current game state.\n\n    Raises:\n        MethodNotImplementedError: If the method is not implemented.\n\n    Returns:\n        Iterable[Player]: The list of player(s) who won the game.\n    \"\"\"\n    raise MethodNotImplementedError()\n</code></pre>"},{"location":"reference/seahorse/game/master/#seahorse.game.master.GameMaster.get_custom_stats","title":"<code>get_custom_stats()</code>","text":"<p>Returns:</p> Type Description <code>list[CustomStat]</code> <p>list[CustomState]: The custom statistics of the game.</p> Source code in <code>src/seahorse/game/master.py</code> <pre><code>def get_custom_stats(self) -&gt; list[CustomStat]:\n    \"\"\"\n    Returns:\n        list[CustomState]: The custom statistics of the game.\n    \"\"\"\n    if not hasattr(self, \"custom_stats\"):\n        self.custom_stats = self.compute_custom_stats()\n    return self.custom_stats\n</code></pre>"},{"location":"reference/seahorse/game/master/#seahorse.game.master.GameMaster.get_game_state","title":"<code>get_game_state()</code>","text":"<p>Returns:</p> Name Type Description <code>GameState</code> <code>GameState</code> <p>The current game state.</p> Source code in <code>src/seahorse/game/master.py</code> <pre><code>def get_game_state(self) -&gt; GameState:\n    \"\"\"\n    Returns:\n        GameState: The current game state.\n    \"\"\"\n    return self.current_game_state\n</code></pre>"},{"location":"reference/seahorse/game/master/#seahorse.game.master.GameMaster.get_json_path","title":"<code>get_json_path()</code>","text":"<p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The path of the log file.</p> Source code in <code>src/seahorse/game/master.py</code> <pre><code>def get_json_path(self) -&gt; str:\n    \"\"\"\n    Returns:\n        str: The path of the log file.\n    \"\"\"\n    return self.log_level\n</code></pre>"},{"location":"reference/seahorse/game/master/#seahorse.game.master.GameMaster.get_name","title":"<code>get_name()</code>","text":"<p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the game.</p> Source code in <code>src/seahorse/game/master.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"\n    Returns:\n        str: The name of the game.\n    \"\"\"\n    return self.name\n</code></pre>"},{"location":"reference/seahorse/game/master/#seahorse.game.master.GameMaster.get_scores","title":"<code>get_scores()</code>","text":"<p>Returns:</p> Name Type Description <code>Dict</code> <code>dict[int, float]</code> <p>The scores of the current state.</p> Source code in <code>src/seahorse/game/master.py</code> <pre><code>def get_scores(self) -&gt; dict[int, float]:\n    \"\"\"\n    Returns:\n        Dict: The scores of the current state.\n    \"\"\"\n    return self.current_game_state.get_scores()\n</code></pre>"},{"location":"reference/seahorse/game/master/#seahorse.game.master.GameMaster.get_winner","title":"<code>get_winner(looser_ids=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>looser_ids</code> <code>Container[int]</code> <p>The IDs of the players who lost the game.</p> <code>None</code> <p>Returns:     Player: The winner(s) of the game.</p> Source code in <code>src/seahorse/game/master.py</code> <pre><code>def get_winner(self, looser_ids: Container[int] | None = None) -&gt; list[Player]:\n    \"\"\"\n    Arguments:\n        looser_ids (Container[int], optional): The IDs of the players who lost the game.\n        If provided, the winners will be all players except these ones.\n    Returns:\n        Player: The winner(s) of the game.\n\n    \"\"\"\n    if not hasattr(self, \"winner\"):\n        if looser_ids is not None:\n            self.winner = [player for player in self.current_game_state.get_players()\n                           if player.get_id() not in looser_ids]\n        else:\n            self.winner = self.compute_winner()\n\n    return self.winner\n</code></pre>"},{"location":"reference/seahorse/game/master/#seahorse.game.master.GameMaster.play_game","title":"<code>play_game()</code>  <code>async</code>","text":"<p>Play the game.</p> <p>Returns:</p> Type Description <code>list[Player]</code> <p>Iterable[Player]: The winner(s) of the game.</p> Source code in <code>src/seahorse/game/master.py</code> <pre><code>async def play_game(self) -&gt; list[Player]:\n    \"\"\"\n    Play the game.\n\n    Returns:\n        Iterable[Player]: The winner(s) of the game.\n    \"\"\"\n    # Prepare the game state JSON and add remaining time info\n    play_payload = self.current_game_state.to_json()\n    play_payload[\"remaining_time\"] = self.remaining_time.copy()\n    await self.emitter.sio.emit(\n        \"play\",\n        json.dumps(play_payload, default=lambda x: x.to_json()),\n    )\n    id2player={}\n    for player in self.get_game_state().get_players() :\n        id2player[player.get_id()]=player.get_name()\n        logger.info(f\"Player : {player.get_name()} - {player.get_id()}\")\n    while not self.current_game_state.is_done():\n        try:\n            logger.info(f\"Player now playing : {self.get_game_state().get_next_player().get_name()} \"\n                        f\"- {self.get_game_state().get_next_player().get_id()}\")\n            self.current_game_state = await self.step()\n        except (ActionNotPermittedError,SeahorseTimeoutError,StopAndStartError) as e:\n            if isinstance(e,SeahorseTimeoutError):\n                logger.error(f\"Time credit expired for player {self.current_game_state.get_next_player()}\")\n            elif isinstance(e,ActionNotPermittedError) :\n                logger.error(f\"Action not permitted for player {self.current_game_state.get_next_player()}\")\n\n            temp_score = copy.copy(self.current_game_state.get_scores())\n            id_player_error = self.current_game_state.get_next_player().get_id()\n            other_player = next(iter([player.get_id() for player in self.current_game_state.get_players() if\n                                      player.get_id()!=id_player_error]))\n            temp_score[id_player_error] = -1e9\n            temp_score[other_player] = 1e9\n            for key in temp_score.keys():\n                logger.info(f\"{id2player[key]}:{temp_score[key]}\")\n\n            for player in self.get_winner(looser_ids={id_player_error}) :\n                logger.info(f\"Winner - {player.get_name()}\")\n\n            await self.emitter.sio.emit(\"done\",json.dumps({\n                \"players\": [{\"id\":player.get_id(), \"name\":player.get_name()}\n                            for player in self.current_game_state.get_players()],\n                \"scores\": self.get_scores(),\n                \"custom_stats\": self.get_custom_stats(),\n                \"winners_id\": [player.get_id() for player in self.get_winner()],\n                \"status\": \"cancelled\",\n            }))\n\n            logger.verdict(f\"{self.current_game_state.get_next_player().get_name()} has been disqualified\")\n\n            return self.winner\n\n        logger.info(f\"Current game state: \\n{self.current_game_state.get_rep()}\")\n\n        # Prepare the game state JSON and add remaining time info\n        play_payload = self.current_game_state.to_json()\n        play_payload[\"remaining_time\"] = self.remaining_time.copy()\n        await self.emitter.sio.emit(\n            \"play\",\n            json.dumps(play_payload, default=lambda x: x.to_json()),\n        )\n\n    scores = self.get_scores()\n    for key in scores.keys():\n            logger.info(f\"{id2player[key]}:{(scores[key])}\")\n\n    for player in self.get_winner() :\n        logger.info(f\"Winner - {player.get_name()}\")\n\n    await self.emitter.sio.emit(\"done\",json.dumps({\n        \"players\": [{\"id\":player.get_id(), \"name\":player.get_name()}\n                    for player in self.current_game_state.get_players()],\n        \"scores\": self.get_scores(),\n        \"custom_stats\": self.get_custom_stats(),\n        \"winners_id\": [player.get_id() for player in self.get_winner()],\n        \"status\": \"done\",\n    }))\n    logger.verdict(f\"{','.join(w.get_name() for w in self.get_winner())} has won the game\")\n    return self.winner\n</code></pre>"},{"location":"reference/seahorse/game/master/#seahorse.game.master.GameMaster.record_game","title":"<code>record_game(listeners=None)</code>","text":"<p>Starts a game and broadcasts its successive states.</p> Source code in <code>src/seahorse/game/master.py</code> <pre><code>def record_game(self, listeners:Optional[list[EventSlave]]=None) -&gt; None:\n    \"\"\"\n    Starts a game and broadcasts its successive states.\n    \"\"\"\n    self.emitter.start(self.play_game, self.players+(listeners if listeners else []))\n</code></pre>"},{"location":"reference/seahorse/game/master/#seahorse.game.master.GameMaster.step","title":"<code>step()</code>  <code>async</code>","text":"<p>Calls the next player move.</p> <p>Returns:</p> Name Type Description <code>GamseState</code> <code>GameState</code> <p>The new game_state.</p> Source code in <code>src/seahorse/game/master.py</code> <pre><code>async def step(self) -&gt; GameState:\n    \"\"\"\n    Calls the next player move.\n\n    Returns:\n        GamseState : The new game_state.\n    \"\"\"\n    next_player = self.current_game_state.get_next_player()\n\n    possible_actions = self.current_game_state.get_possible_heavy_actions()\n\n    start = time.time()\n\n    logger.info(f\"time : {self.remaining_time[next_player.get_id()]}\")\n    if isinstance(next_player,EventSlave):\n        action = await next_player.play(self.current_game_state,\n                                        remaining_time=self.remaining_time[next_player.get_id()])\n    else:\n        action = next_player.play(self.current_game_state,\n                                  remaining_time=self.remaining_time[next_player.get_id()])\n    tstp = time.time()\n    self.remaining_time[next_player.get_id()] -= (tstp-start)\n    if self.remaining_time[next_player.get_id()] &lt; 0:\n        raise SeahorseTimeoutError()\n\n    action = action.get_heavy_action(self.current_game_state)\n    if action not in possible_actions:\n        raise ActionNotPermittedError()\n\n    return action.get_next_game_state()\n</code></pre>"},{"location":"reference/seahorse/game/master/#seahorse.game.master.GameMaster.update_log","title":"<code>update_log()</code>","text":"<p>Updates the log file.</p> <p>Raises:</p> Type Description <code>MethodNotImplementedError</code> <p>If the method is not implemented.</p> Source code in <code>src/seahorse/game/master.py</code> <pre><code>def update_log(self) -&gt; None:\n    \"\"\"\n    Updates the log file.\n\n    Raises:\n        MethodNotImplementedError: If the method is not implemented.\n    \"\"\"\n    raise MethodNotImplementedError()\n</code></pre>"},{"location":"reference/seahorse/game/representation/","title":"Representation","text":""},{"location":"reference/seahorse/game/representation/#seahorse.game.representation.Representation","title":"<code>Representation</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>A class representing a game representation.</p> <p>Attributes:</p> Name Type Description <code>env</code> <code>dict</code> <p>The dictionary of the current state.</p> Source code in <code>src/seahorse/game/representation.py</code> <pre><code>class Representation(Serializable):\n    \"\"\"\n    A class representing a game representation.\n\n    Attributes:\n        env (dict): The dictionary of the current state.\n    \"\"\"\n\n    def __init__(self, env: dict) -&gt; None:\n        \"\"\"\n        Initializes a new instance of the Representation class.\n\n        Args:\n            env (dict): The dictionary of the current state.\n        \"\"\"\n        self.env = env\n\n    def get_env(self) -&gt; dict:\n        \"\"\"\n        Gets the dictionary of the environment.\n\n        Returns:\n            dict: The dictionary of the environment.\n        \"\"\"\n        return self.env\n\n    def find(self, to_find: Any) -&gt; Any:\n        \"\"\"\n        Finds a key directly in the environment.\n\n        Args:\n            to_find (Any): The key to find.\n\n        Returns:\n            Any: The value of the cell.\n        \"\"\"\n        if to_find not in self.env.keys():\n            return -1\n        else:\n            return self.env[to_find]\n\n    @abstractmethod\n    def __hash__(self) -&gt; int:\n        raise MethodNotImplementedError()\n\n    @abstractmethod\n    def __eq__(self, __value: object) -&gt; bool:\n        raise MethodNotImplementedError()\n\n    @abstractmethod\n    def __str__(self) -&gt; str:\n        raise MethodNotImplementedError()\n</code></pre>"},{"location":"reference/seahorse/game/representation/#seahorse.game.representation.Representation.__init__","title":"<code>__init__(env)</code>","text":"<p>Initializes a new instance of the Representation class.</p> <p>Parameters:</p> Name Type Description Default <code>env</code> <code>dict</code> <p>The dictionary of the current state.</p> required Source code in <code>src/seahorse/game/representation.py</code> <pre><code>def __init__(self, env: dict) -&gt; None:\n    \"\"\"\n    Initializes a new instance of the Representation class.\n\n    Args:\n        env (dict): The dictionary of the current state.\n    \"\"\"\n    self.env = env\n</code></pre>"},{"location":"reference/seahorse/game/representation/#seahorse.game.representation.Representation.find","title":"<code>find(to_find)</code>","text":"<p>Finds a key directly in the environment.</p> <p>Parameters:</p> Name Type Description Default <code>to_find</code> <code>Any</code> <p>The key to find.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The value of the cell.</p> Source code in <code>src/seahorse/game/representation.py</code> <pre><code>def find(self, to_find: Any) -&gt; Any:\n    \"\"\"\n    Finds a key directly in the environment.\n\n    Args:\n        to_find (Any): The key to find.\n\n    Returns:\n        Any: The value of the cell.\n    \"\"\"\n    if to_find not in self.env.keys():\n        return -1\n    else:\n        return self.env[to_find]\n</code></pre>"},{"location":"reference/seahorse/game/representation/#seahorse.game.representation.Representation.get_env","title":"<code>get_env()</code>","text":"<p>Gets the dictionary of the environment.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The dictionary of the environment.</p> Source code in <code>src/seahorse/game/representation.py</code> <pre><code>def get_env(self) -&gt; dict:\n    \"\"\"\n    Gets the dictionary of the environment.\n\n    Returns:\n        dict: The dictionary of the environment.\n    \"\"\"\n    return self.env\n</code></pre>"},{"location":"reference/seahorse/game/game_layout/board/","title":"Board","text":""},{"location":"reference/seahorse/game/game_layout/board/#seahorse.game.game_layout.board.Board","title":"<code>Board</code>","text":"<p>               Bases: <code>Representation</code></p> <p>A class representing the game board.</p> <p>Attributes:</p> Name Type Description <code>env</code> <code>dict[Tuple[int], Piece]</code> <p>The environment dictionary composed of pieces.</p> <code>dimensions</code> <code>list[int]</code> <p>The dimensions of the board.</p> Source code in <code>src/seahorse/game/game_layout/board.py</code> <pre><code>class Board(Representation):\n    \"\"\"\n    A class representing the game board.\n\n    Attributes:\n        env (dict[Tuple[int], Piece]): The environment dictionary composed of pieces.\n        dimensions (list[int]): The dimensions of the board.\n    \"\"\"\n\n    def __init__(self, env: dict[tuple[int], Piece], dim: list[int]) -&gt; None:\n        \"\"\"\n        Initializes a new instance of the Board class.\n\n        Args:\n            env (dict[Tuple[int], Piece]): The environment dictionary composed of pieces.\n            dim (list[int]): The dimensions of the board.\n        \"\"\"\n        super().__init__(env)\n        self.dimensions = dim\n\n    def get_dimensions(self) -&gt; list[int]:\n        \"\"\"\n        Gets the dimensions of the board.\n\n        Returns:\n            list[int]: The list of dimensions.\n        \"\"\"\n        return self.dimensions\n\n    def get_pieces_player(self, owner: Player) -&gt; tuple[int, list[Piece]]:\n        \"\"\"\n        Gets the pieces owned by a specific player.\n\n        Args:\n            owner (Player): The player specified.\n\n        Returns:\n            Tuple[int, list[Piece]]: The number of pieces owned by the player and the list of their pieces.\n        \"\"\"\n        pieces_list = []\n        number = 0\n        for key in self.env.keys():\n            if self.env[key].get_owner_id() == owner.get_id():\n                number += 1\n                pieces_list.append(key)\n        return number, pieces_list\n\n    def __hash__(self):\n        return hash(frozenset([(hash(pos), hash(piece)) for pos, piece in self.env.items()]))\n\n    def __eq__(self, __value: object) -&gt; bool:\n        return hash(self) == hash(__value)\n\n    def __str__(self) -&gt; str:\n        dim = self.get_dimensions()\n        to_print = \"\"\n        for i in range(dim[0]):\n            for j in range(dim[1]):\n                if self.get_env().get((i, j), -1) != -1:\n                    to_print += str(self.get_env().get((i, j)).get_type()) + \" \"\n                else:\n                    to_print += \"_ \"\n            to_print += \"\\n\"\n        return to_print\n</code></pre>"},{"location":"reference/seahorse/game/game_layout/board/#seahorse.game.game_layout.board.Board.__init__","title":"<code>__init__(env, dim)</code>","text":"<p>Initializes a new instance of the Board class.</p> <p>Parameters:</p> Name Type Description Default <code>env</code> <code>dict[Tuple[int], Piece]</code> <p>The environment dictionary composed of pieces.</p> required <code>dim</code> <code>list[int]</code> <p>The dimensions of the board.</p> required Source code in <code>src/seahorse/game/game_layout/board.py</code> <pre><code>def __init__(self, env: dict[tuple[int], Piece], dim: list[int]) -&gt; None:\n    \"\"\"\n    Initializes a new instance of the Board class.\n\n    Args:\n        env (dict[Tuple[int], Piece]): The environment dictionary composed of pieces.\n        dim (list[int]): The dimensions of the board.\n    \"\"\"\n    super().__init__(env)\n    self.dimensions = dim\n</code></pre>"},{"location":"reference/seahorse/game/game_layout/board/#seahorse.game.game_layout.board.Board.get_dimensions","title":"<code>get_dimensions()</code>","text":"<p>Gets the dimensions of the board.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>list[int]: The list of dimensions.</p> Source code in <code>src/seahorse/game/game_layout/board.py</code> <pre><code>def get_dimensions(self) -&gt; list[int]:\n    \"\"\"\n    Gets the dimensions of the board.\n\n    Returns:\n        list[int]: The list of dimensions.\n    \"\"\"\n    return self.dimensions\n</code></pre>"},{"location":"reference/seahorse/game/game_layout/board/#seahorse.game.game_layout.board.Board.get_pieces_player","title":"<code>get_pieces_player(owner)</code>","text":"<p>Gets the pieces owned by a specific player.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>Player</code> <p>The player specified.</p> required <p>Returns:</p> Type Description <code>tuple[int, list[Piece]]</code> <p>Tuple[int, list[Piece]]: The number of pieces owned by the player and the list of their pieces.</p> Source code in <code>src/seahorse/game/game_layout/board.py</code> <pre><code>def get_pieces_player(self, owner: Player) -&gt; tuple[int, list[Piece]]:\n    \"\"\"\n    Gets the pieces owned by a specific player.\n\n    Args:\n        owner (Player): The player specified.\n\n    Returns:\n        Tuple[int, list[Piece]]: The number of pieces owned by the player and the list of their pieces.\n    \"\"\"\n    pieces_list = []\n    number = 0\n    for key in self.env.keys():\n        if self.env[key].get_owner_id() == owner.get_id():\n            number += 1\n            pieces_list.append(key)\n    return number, pieces_list\n</code></pre>"},{"location":"reference/seahorse/game/game_layout/board/#seahorse.game.game_layout.board.Piece","title":"<code>Piece</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>A class representing a piece in the game.</p> <p>Attributes:</p> Name Type Description <code>piece_type</code> <code>str</code> <p>The type of the piece.</p> <code>owner_id</code> <code>int</code> <p>The ID of the player who possesses the piece.</p> Source code in <code>src/seahorse/game/game_layout/board.py</code> <pre><code>class Piece(Serializable):\n    \"\"\"\n    A class representing a piece in the game.\n\n    Attributes:\n        piece_type (str): The type of the piece.\n        owner_id (int): The ID of the player who possesses the piece.\n    \"\"\"\n\n    def __init__(self, piece_type: str, owner: Player | None = None, owner_id: int=-1) -&gt; None:\n        \"\"\"\n        Initializes a new instance of the Piece class.\n\n        Args:\n            piece_type (str): The type of the piece.\n            owner (Player): The player who possesses the piece.\n        \"\"\"\n        self.piece_type = piece_type\n        if owner is None:\n            self.owner_id = owner_id\n        else:\n            self.owner_id = owner.get_id()\n\n    def get_type(self) -&gt; str:\n        \"\"\"\n        Gets the type of the piece.\n\n        Returns:\n            str: The type of the piece.\n        \"\"\"\n        return self.piece_type\n\n    def get_owner_id(self) -&gt; int:\n        \"\"\"\n        Gets the ID of the owner of the piece.\n\n        Returns:\n            int: The ID of the owner.\n        \"\"\"\n        return self.owner_id\n\n    def copy(self) -&gt; Piece:\n        \"\"\"\n        Creates a copy of the piece.\n\n        Returns:\n            Piece: A copy of the piece.\n        \"\"\"\n        return Piece(self.piece_type, None)\n\n    def __hash__(self) -&gt; int:\n        return hash((hash(self.get_type()), hash(self.owner_id)))\n\n    def __eq__(self, __value: object) -&gt; bool:\n        return hash(self) == hash(__value)\n\n    #def __str__(self) -&gt; str:\n    #    return self.get_type()\n\n    def to_json(self) -&gt; str:\n        return self.__dict__\n\n    @classmethod\n    def from_json(cls,data) -&gt; str:\n        return cls(**json.loads(data))\n</code></pre>"},{"location":"reference/seahorse/game/game_layout/board/#seahorse.game.game_layout.board.Piece.__init__","title":"<code>__init__(piece_type, owner=None, owner_id=-1)</code>","text":"<p>Initializes a new instance of the Piece class.</p> <p>Parameters:</p> Name Type Description Default <code>piece_type</code> <code>str</code> <p>The type of the piece.</p> required <code>owner</code> <code>Player</code> <p>The player who possesses the piece.</p> <code>None</code> Source code in <code>src/seahorse/game/game_layout/board.py</code> <pre><code>def __init__(self, piece_type: str, owner: Player | None = None, owner_id: int=-1) -&gt; None:\n    \"\"\"\n    Initializes a new instance of the Piece class.\n\n    Args:\n        piece_type (str): The type of the piece.\n        owner (Player): The player who possesses the piece.\n    \"\"\"\n    self.piece_type = piece_type\n    if owner is None:\n        self.owner_id = owner_id\n    else:\n        self.owner_id = owner.get_id()\n</code></pre>"},{"location":"reference/seahorse/game/game_layout/board/#seahorse.game.game_layout.board.Piece.copy","title":"<code>copy()</code>","text":"<p>Creates a copy of the piece.</p> <p>Returns:</p> Name Type Description <code>Piece</code> <code>Piece</code> <p>A copy of the piece.</p> Source code in <code>src/seahorse/game/game_layout/board.py</code> <pre><code>def copy(self) -&gt; Piece:\n    \"\"\"\n    Creates a copy of the piece.\n\n    Returns:\n        Piece: A copy of the piece.\n    \"\"\"\n    return Piece(self.piece_type, None)\n</code></pre>"},{"location":"reference/seahorse/game/game_layout/board/#seahorse.game.game_layout.board.Piece.get_owner_id","title":"<code>get_owner_id()</code>","text":"<p>Gets the ID of the owner of the piece.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The ID of the owner.</p> Source code in <code>src/seahorse/game/game_layout/board.py</code> <pre><code>def get_owner_id(self) -&gt; int:\n    \"\"\"\n    Gets the ID of the owner of the piece.\n\n    Returns:\n        int: The ID of the owner.\n    \"\"\"\n    return self.owner_id\n</code></pre>"},{"location":"reference/seahorse/game/game_layout/board/#seahorse.game.game_layout.board.Piece.get_type","title":"<code>get_type()</code>","text":"<p>Gets the type of the piece.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The type of the piece.</p> Source code in <code>src/seahorse/game/game_layout/board.py</code> <pre><code>def get_type(self) -&gt; str:\n    \"\"\"\n    Gets the type of the piece.\n\n    Returns:\n        str: The type of the piece.\n    \"\"\"\n    return self.piece_type\n</code></pre>"},{"location":"reference/seahorse/player/player/","title":"Player","text":""},{"location":"reference/seahorse/player/player/#seahorse.player.player.Player","title":"<code>Player</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>A base class representing a player in the game.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the player.</p> <code>name</code> <code>str) </code> <p>the name of the player</p> Source code in <code>src/seahorse/player/player.py</code> <pre><code>class Player(Serializable):\n    \"\"\"\n    A base class representing a player in the game.\n\n    Attributes:\n        id (int): The ID of the player.\n        name (str) : the name of the player\n    \"\"\"\n\n    def __init__(self, name: str = \"bob\",*,id:int | None = None,**_) -&gt; None:\n        \"\"\"\n        Initializes a new instance of the Player class.\n\n        Args:\n            name (str, optional): The name of the player. Defaults to \"bob\".\n            hard_id (int, optional, keyword-only): Set the player's id in case of distant loading\n        \"\"\"\n        self.name = name\n        if id is None:\n            self.id = builtins.id(self)\n        else:\n            self.id = id\n\n\n    def play(self, current_state: GameState, remaining_time: int) -&gt; Action:\n        \"\"\"\n        Implements the player's logic and calls compute_action with minimal information.\n\n        Args:\n            current_state (GameState): The current game state.\n\n        Raises:\n            MethodNotImplementedError: If the method is not implemented in the derived class.\n\n        Returns:\n            Action: The resulting action.\n        \"\"\"\n        # TODO: check score ????\n        return self.compute_action(current_state=current_state, remaining_time=remaining_time)\n\n    @abstractmethod\n    def compute_action(self, **kwargs) -&gt; Action:\n        \"\"\"\n        Should be dedicated to adversarial search.\n\n        Args:\n            **kwargs: Additional arguments.\n\n        Raises:\n            MethodNotImplementedError: If the method is not implemented in the derived class.\n\n        Returns:\n            Action: The action to play.\n        \"\"\"\n        raise MethodNotImplementedError()\n\n    def get_id(self) -&gt; int:\n        \"\"\"\n        Returns:\n            int: The ID of the player.\n        \"\"\"\n        return self.id\n\n    def get_name(self) -&gt; str:\n        \"\"\"\n        Returns:\n            str: The name of the player.\n        \"\"\"\n        return self.name\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns a string representation of the Player object.\n\n        Returns:\n            str: The string representation.\n        \"\"\"\n        return f\"Player {self.get_name()}({self.get_id()})\"\n</code></pre>"},{"location":"reference/seahorse/player/player/#seahorse.player.player.Player.__init__","title":"<code>__init__(name='bob', *, id=None, **_)</code>","text":"<p>Initializes a new instance of the Player class.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the player. Defaults to \"bob\".</p> <code>'bob'</code> <code>hard_id</code> <code>(int, optional, keyword - only)</code> <p>Set the player's id in case of distant loading</p> required Source code in <code>src/seahorse/player/player.py</code> <pre><code>def __init__(self, name: str = \"bob\",*,id:int | None = None,**_) -&gt; None:\n    \"\"\"\n    Initializes a new instance of the Player class.\n\n    Args:\n        name (str, optional): The name of the player. Defaults to \"bob\".\n        hard_id (int, optional, keyword-only): Set the player's id in case of distant loading\n    \"\"\"\n    self.name = name\n    if id is None:\n        self.id = builtins.id(self)\n    else:\n        self.id = id\n</code></pre>"},{"location":"reference/seahorse/player/player/#seahorse.player.player.Player.__str__","title":"<code>__str__()</code>","text":"<p>Returns a string representation of the Player object.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The string representation.</p> Source code in <code>src/seahorse/player/player.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns a string representation of the Player object.\n\n    Returns:\n        str: The string representation.\n    \"\"\"\n    return f\"Player {self.get_name()}({self.get_id()})\"\n</code></pre>"},{"location":"reference/seahorse/player/player/#seahorse.player.player.Player.compute_action","title":"<code>compute_action(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Should be dedicated to adversarial search.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional arguments.</p> <code>{}</code> <p>Raises:</p> Type Description <code>MethodNotImplementedError</code> <p>If the method is not implemented in the derived class.</p> <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>The action to play.</p> Source code in <code>src/seahorse/player/player.py</code> <pre><code>@abstractmethod\ndef compute_action(self, **kwargs) -&gt; Action:\n    \"\"\"\n    Should be dedicated to adversarial search.\n\n    Args:\n        **kwargs: Additional arguments.\n\n    Raises:\n        MethodNotImplementedError: If the method is not implemented in the derived class.\n\n    Returns:\n        Action: The action to play.\n    \"\"\"\n    raise MethodNotImplementedError()\n</code></pre>"},{"location":"reference/seahorse/player/player/#seahorse.player.player.Player.get_id","title":"<code>get_id()</code>","text":"<p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The ID of the player.</p> Source code in <code>src/seahorse/player/player.py</code> <pre><code>def get_id(self) -&gt; int:\n    \"\"\"\n    Returns:\n        int: The ID of the player.\n    \"\"\"\n    return self.id\n</code></pre>"},{"location":"reference/seahorse/player/player/#seahorse.player.player.Player.get_name","title":"<code>get_name()</code>","text":"<p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the player.</p> Source code in <code>src/seahorse/player/player.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"\n    Returns:\n        str: The name of the player.\n    \"\"\"\n    return self.name\n</code></pre>"},{"location":"reference/seahorse/player/player/#seahorse.player.player.Player.play","title":"<code>play(current_state, remaining_time)</code>","text":"<p>Implements the player's logic and calls compute_action with minimal information.</p> <p>Parameters:</p> Name Type Description Default <code>current_state</code> <code>GameState</code> <p>The current game state.</p> required <p>Raises:</p> Type Description <code>MethodNotImplementedError</code> <p>If the method is not implemented in the derived class.</p> <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>The resulting action.</p> Source code in <code>src/seahorse/player/player.py</code> <pre><code>def play(self, current_state: GameState, remaining_time: int) -&gt; Action:\n    \"\"\"\n    Implements the player's logic and calls compute_action with minimal information.\n\n    Args:\n        current_state (GameState): The current game state.\n\n    Raises:\n        MethodNotImplementedError: If the method is not implemented in the derived class.\n\n    Returns:\n        Action: The resulting action.\n    \"\"\"\n    # TODO: check score ????\n    return self.compute_action(current_state=current_state, remaining_time=remaining_time)\n</code></pre>"},{"location":"reference/seahorse/player/proxies/","title":"Proxies","text":""},{"location":"reference/seahorse/player/proxies/#seahorse.player.proxies.InteractivePlayerProxy","title":"<code>InteractivePlayerProxy</code>","text":"<p>               Bases: <code>LocalPlayerProxy</code></p> <p>Proxy for interactive players, inherits from <code>LocalPlayerProxy</code></p> Source code in <code>src/seahorse/player/proxies.py</code> <pre><code>class InteractivePlayerProxy(LocalPlayerProxy):\n    \"\"\"Proxy for interactive players,\n       inherits from `LocalPlayerProxy`\n    \"\"\"\n    def __init__(self, mimics: Player, gui_path:Optional[str]=None, *args, **kwargs) -&gt; None:\n        \"\"\"\n\n        Args:\n            mimics (type[Player]): A wrapped player, the internal logic will be overridden by an interactive one\n            gui_path (str, optional): If the interaction is supposed to happen on the host machine, provide a GUI path to start it up. Defaults to None.\n        \"\"\"\n        super().__init__(mimics, *args, **kwargs)\n        self.wrapped_player.player_type = \"interactive\"\n        self.path = gui_path\n        self.shared_sid = None\n        self.sid = None\n\n    async def play(self, current_state: GameState, **_) -&gt; Action:\n        if self.shared_sid and not self.sid:\n            self.sid=self.shared_sid.sid\n        while True:\n            data_gui = json.loads(await EventMaster.get_instance().wait_for_event(self.sid,\"interact\",flush_until=time.time()))\n            try:\n                data = current_state.convert_gui_data_to_action_data(data_gui)\n                action = LightAction(data).get_heavy_action(current_state)\n\n            except MethodNotImplementedError:\n                #TODO: handle this case\n                action = Action.from_json(data)\n\n            if action in current_state.get_possible_heavy_actions():\n                break\n            else:\n                await EventMaster.get_instance().sio.emit(\"ActionNotPermitted\",None)\n        return action\n\n    async def listen(self, master_address, *, keep_alive: bool) -&gt; None:\n        if not self.shared_sid:\n            await super().listen(master_address, keep_alive=keep_alive)\n            embedded_client = GUIClient(path=self.path)\n            await embedded_client.listen()\n            self.sid = embedded_client.sid\n\n    def share_sid(self,proxy:\"InteractivePlayerProxy\"):\n        self.shared_sid=proxy\n</code></pre>"},{"location":"reference/seahorse/player/proxies/#seahorse.player.proxies.InteractivePlayerProxy.__init__","title":"<code>__init__(mimics, gui_path=None, *args, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>mimics</code> <code>type[Player]</code> <p>A wrapped player, the internal logic will be overridden by an interactive one</p> required <code>gui_path</code> <code>str</code> <p>If the interaction is supposed to happen on the host machine, provide a GUI path to start it up. Defaults to None.</p> <code>None</code> Source code in <code>src/seahorse/player/proxies.py</code> <pre><code>def __init__(self, mimics: Player, gui_path:Optional[str]=None, *args, **kwargs) -&gt; None:\n    \"\"\"\n\n    Args:\n        mimics (type[Player]): A wrapped player, the internal logic will be overridden by an interactive one\n        gui_path (str, optional): If the interaction is supposed to happen on the host machine, provide a GUI path to start it up. Defaults to None.\n    \"\"\"\n    super().__init__(mimics, *args, **kwargs)\n    self.wrapped_player.player_type = \"interactive\"\n    self.path = gui_path\n    self.shared_sid = None\n    self.sid = None\n</code></pre>"},{"location":"reference/seahorse/player/proxies/#seahorse.player.proxies.LocalPlayerProxy","title":"<code>LocalPlayerProxy</code>","text":"<p>               Bases: <code>Serializable</code>, <code>EventSlave</code></p> <p>A class representing a local player proxy.</p> <p>Attributes:</p> Name Type Description <code>wrapped_player</code> <code>Player</code> <p>The wrapped player object.</p> <p>Methods:</p> Name Description <code>play</code> <p>GameState) -&gt; Action: Plays a move.</p> Source code in <code>src/seahorse/player/proxies.py</code> <pre><code>class LocalPlayerProxy(Serializable,EventSlave):\n    \"\"\"\n    A class representing a local player proxy.\n\n    Attributes:\n        wrapped_player (Player): The wrapped player object.\n\n    Methods:\n        play(current_state: GameState) -&gt; Action: Plays a move.\n    \"\"\"\n\n    def __init__(self, wrapped_player: Player,gs:type=GameState) -&gt; None:\n        \"\"\"\n        Initializes a new instance of the LocalPlayerProxy class.\n\n        Args:\n            wrapped_player (Player): The player object to wrap.\n        \"\"\"\n        self.wrapped_player = wrapped_player\n        self.activate(self.wrapped_player.name,wrapped_id=wrapped_player.get_id())\n        @self.sio.on(\"turn\")\n        async def handle_turn(*data):\n            logger.info(f\"{self.wrapped_player.name} is playing\")\n            logger.debug(f\"Data received : {data}\")\n            deserialized = json.loads(data[0])\n            logger.debug(f\"Deserialized data : \\n{deserialized}\")\n            action = await self.play(gs.from_json(data[0],next_player=self),remaining_time = deserialized[\"remaining_time\"])\n            logger.info(f\"{self.wrapped_player} played the following action : \\n{action}\")\n\n        @self.sio.on(\"update_id\")\n        async def update_id(data):\n            logger.debug(\"update_id received\",json.loads(data)[\"new_id\"])\n            self.wrapped_player.id = json.loads(data)[\"new_id\"]\n\n    @event_emitting(\"action\")\n    def play(self, current_state: GameState, remaining_time: int) -&gt; Action:\n        \"\"\"\n        Plays a move.\n\n        Args:\n            current_state (GameState): The current game state.\n\n        Returns:\n            Action: The action resulting from the move.\n        \"\"\"\n        return self.compute_action(current_state=current_state, remaining_time=remaining_time).get_heavy_action(current_state)\n\n    def __getattr__(self, attr):\n        return getattr(self.wrapped_player, attr)\n\n    def __hash__(self) -&gt; int:\n        return hash(self.wrapped_player)\n\n    def __eq__(self, __value: object) -&gt; bool:\n        return hash(self) == hash(__value)\n\n    def __str__(self) -&gt; str:\n        return f\"Player {self.wrapped_player.get_name()} (ID: {self.wrapped_player.get_id()}).\"\n\n    def to_json(self) -&gt; dict:\n        return self.wrapped_player.to_json()\n</code></pre>"},{"location":"reference/seahorse/player/proxies/#seahorse.player.proxies.LocalPlayerProxy.__init__","title":"<code>__init__(wrapped_player, gs=GameState)</code>","text":"<p>Initializes a new instance of the LocalPlayerProxy class.</p> <p>Parameters:</p> Name Type Description Default <code>wrapped_player</code> <code>Player</code> <p>The player object to wrap.</p> required Source code in <code>src/seahorse/player/proxies.py</code> <pre><code>def __init__(self, wrapped_player: Player,gs:type=GameState) -&gt; None:\n    \"\"\"\n    Initializes a new instance of the LocalPlayerProxy class.\n\n    Args:\n        wrapped_player (Player): The player object to wrap.\n    \"\"\"\n    self.wrapped_player = wrapped_player\n    self.activate(self.wrapped_player.name,wrapped_id=wrapped_player.get_id())\n    @self.sio.on(\"turn\")\n    async def handle_turn(*data):\n        logger.info(f\"{self.wrapped_player.name} is playing\")\n        logger.debug(f\"Data received : {data}\")\n        deserialized = json.loads(data[0])\n        logger.debug(f\"Deserialized data : \\n{deserialized}\")\n        action = await self.play(gs.from_json(data[0],next_player=self),remaining_time = deserialized[\"remaining_time\"])\n        logger.info(f\"{self.wrapped_player} played the following action : \\n{action}\")\n\n    @self.sio.on(\"update_id\")\n    async def update_id(data):\n        logger.debug(\"update_id received\",json.loads(data)[\"new_id\"])\n        self.wrapped_player.id = json.loads(data)[\"new_id\"]\n</code></pre>"},{"location":"reference/seahorse/player/proxies/#seahorse.player.proxies.LocalPlayerProxy.play","title":"<code>play(current_state, remaining_time)</code>","text":"<p>Plays a move.</p> <p>Parameters:</p> Name Type Description Default <code>current_state</code> <code>GameState</code> <p>The current game state.</p> required <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>The action resulting from the move.</p> Source code in <code>src/seahorse/player/proxies.py</code> <pre><code>@event_emitting(\"action\")\ndef play(self, current_state: GameState, remaining_time: int) -&gt; Action:\n    \"\"\"\n    Plays a move.\n\n    Args:\n        current_state (GameState): The current game state.\n\n    Returns:\n        Action: The action resulting from the move.\n    \"\"\"\n    return self.compute_action(current_state=current_state, remaining_time=remaining_time).get_heavy_action(current_state)\n</code></pre>"},{"location":"reference/seahorse/player/proxies/#seahorse.player.proxies.RemotePlayerProxy","title":"<code>RemotePlayerProxy</code>","text":"<p>               Bases: <code>Serializable</code>, <code>EventSlave</code></p> <p>A class representing a remote player proxy.</p> <p>Attributes:</p> Name Type Description <code>mimics</code> <code>type[Player]</code> <p>The player type to mimic.</p> <code>sid</code> <p>The session ID.</p> Source code in <code>src/seahorse/player/proxies.py</code> <pre><code>class RemotePlayerProxy(Serializable,EventSlave):\n    \"\"\"\n    A class representing a remote player proxy.\n\n    Attributes:\n        mimics (type[Player]): The player type to mimic.\n        sid: The session ID.\n    \"\"\"\n\n    def __init__(self, mimics: type[Player], *args, **kwargs) -&gt; None:\n        \"\"\"\n        Initializes a new instance of the RemotePlayerProxy class.\n\n        Args:\n            mimics (type[Player]): The player type to mimic.\n            *args: Additional arguments.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        self.mimics = mimics(*args, **kwargs)\n        self.activate(wrapped_id=self.mimics.get_id())\n        self.id = self.mimics.id\n        self.sid = None\n\n    @remote_action(\"turn\")\n    def play(self, *,current_state: GameState, remaining_time: int) -&gt; Action:\n        \"\"\"\n        Plays a move.\n\n        Args:\n            current_state: The game state.\n\n        Returns:\n            Action: The action resulting from the move.\n        \"\"\"\n        pass\n\n    async def listen(self,**_) -&gt; Coroutine[Any, Any, None]:\n        \"\"\"\n        Fires up the listening process\n\n        Returns:\n            Coroutine: A coroutine object.\n        \"\"\"\n        idmap = await EventMaster.get_instance().wait_for_identified_client(self.name,self.id)\n        self.sid = idmap[\"sid\"]\n\n    def __getattr__(self, attr):\n        return getattr(self.mimics, attr)\n\n    def __hash__(self) -&gt; int:\n        return hash(self.sid)\n\n    def __eq__(self, __value: object) -&gt; bool:\n        return hash(self) == hash(__value)\n\n    def to_json(self) -&gt; str:\n        return str(self.wrapped_id)\n</code></pre>"},{"location":"reference/seahorse/player/proxies/#seahorse.player.proxies.RemotePlayerProxy.__init__","title":"<code>__init__(mimics, *args, **kwargs)</code>","text":"<p>Initializes a new instance of the RemotePlayerProxy class.</p> <p>Parameters:</p> Name Type Description Default <code>mimics</code> <code>type[Player]</code> <p>The player type to mimic.</p> required <code>*args</code> <p>Additional arguments.</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>src/seahorse/player/proxies.py</code> <pre><code>def __init__(self, mimics: type[Player], *args, **kwargs) -&gt; None:\n    \"\"\"\n    Initializes a new instance of the RemotePlayerProxy class.\n\n    Args:\n        mimics (type[Player]): The player type to mimic.\n        *args: Additional arguments.\n        **kwargs: Additional keyword arguments.\n    \"\"\"\n    self.mimics = mimics(*args, **kwargs)\n    self.activate(wrapped_id=self.mimics.get_id())\n    self.id = self.mimics.id\n    self.sid = None\n</code></pre>"},{"location":"reference/seahorse/player/proxies/#seahorse.player.proxies.RemotePlayerProxy.listen","title":"<code>listen(**_)</code>  <code>async</code>","text":"<p>Fires up the listening process</p> <p>Returns:</p> Name Type Description <code>Coroutine</code> <code>Coroutine[Any, Any, None]</code> <p>A coroutine object.</p> Source code in <code>src/seahorse/player/proxies.py</code> <pre><code>async def listen(self,**_) -&gt; Coroutine[Any, Any, None]:\n    \"\"\"\n    Fires up the listening process\n\n    Returns:\n        Coroutine: A coroutine object.\n    \"\"\"\n    idmap = await EventMaster.get_instance().wait_for_identified_client(self.name,self.id)\n    self.sid = idmap[\"sid\"]\n</code></pre>"},{"location":"reference/seahorse/player/proxies/#seahorse.player.proxies.RemotePlayerProxy.play","title":"<code>play(*, current_state, remaining_time)</code>","text":"<p>Plays a move.</p> <p>Parameters:</p> Name Type Description Default <code>current_state</code> <code>GameState</code> <p>The game state.</p> required <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>The action resulting from the move.</p> Source code in <code>src/seahorse/player/proxies.py</code> <pre><code>@remote_action(\"turn\")\ndef play(self, *,current_state: GameState, remaining_time: int) -&gt; Action:\n    \"\"\"\n    Plays a move.\n\n    Args:\n        current_state: The game state.\n\n    Returns:\n        Action: The action resulting from the move.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/seahorse/utils/custom_exceptions/","title":"Custom exceptions","text":""},{"location":"reference/seahorse/utils/custom_exceptions/#seahorse.utils.custom_exceptions.ActionNotPermittedError","title":"<code>ActionNotPermittedError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Thrown when trying to generate an action that's not permitted</p> Source code in <code>src/seahorse/utils/custom_exceptions.py</code> <pre><code>class ActionNotPermittedError(Exception):\n    \"\"\"Thrown when trying to generate an action that's not permitted\n    \"\"\"\n\n    def __init__(self,  message: str = \"Action not permitted\"):\n        self.message = message\n        super().__init__(message)\n</code></pre>"},{"location":"reference/seahorse/utils/custom_exceptions/#seahorse.utils.custom_exceptions.AlreadyRunningError","title":"<code>AlreadyRunningError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Thrown when trying to start somethin twice</p> Source code in <code>src/seahorse/utils/custom_exceptions.py</code> <pre><code>class AlreadyRunningError(Exception):\n    \"\"\"Thrown when trying to start somethin twice\n    \"\"\"\n\n    def __init__(self,  message: str = \"Trying to start something twice !\"):\n        self.message = message\n        super().__init__(message)\n</code></pre>"},{"location":"reference/seahorse/utils/custom_exceptions/#seahorse.utils.custom_exceptions.ConnectionProblemError","title":"<code>ConnectionProblemError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Thrown when trying to generate an action that's not permitted</p> Source code in <code>src/seahorse/utils/custom_exceptions.py</code> <pre><code>class ConnectionProblemError(Exception):\n    \"\"\"Thrown when trying to generate an action that's not permitted\n    \"\"\"\n\n    def __init__(self,  message: str = \"Connection problem\"):\n        self.message = message\n        super().__init__(message)\n</code></pre>"},{"location":"reference/seahorse/utils/custom_exceptions/#seahorse.utils.custom_exceptions.MethodNotImplementedError","title":"<code>MethodNotImplementedError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Thrown when trying to use a method not implemented</p> Source code in <code>src/seahorse/utils/custom_exceptions.py</code> <pre><code>class MethodNotImplementedError(Exception):\n    \"\"\"Thrown when trying to use a method not implemented\n    \"\"\"\n\n    def __init__(self,  message: str = \"Method not implemented.\"):\n        self.message = message\n        super().__init__(message)\n</code></pre>"},{"location":"reference/seahorse/utils/custom_exceptions/#seahorse.utils.custom_exceptions.NoGameStateProvidedError","title":"<code>NoGameStateProvidedError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Thrown when trying to get a heavy action from a light action without providing a game state</p> Source code in <code>src/seahorse/utils/custom_exceptions.py</code> <pre><code>class NoGameStateProvidedError(Exception):\n    \"\"\"Thrown when trying to get a heavy action from a light action without providing a game state\n    \"\"\"\n    def __init__(self,  message: str = \"Cannot apply a light action without current game state.\"):\n        self.message = message\n        super().__init__(message)\n</code></pre>"},{"location":"reference/seahorse/utils/custom_exceptions/#seahorse.utils.custom_exceptions.NoTournamentFailError","title":"<code>NoTournamentFailError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Thrown when trying to generate an action that's not permitted</p> Source code in <code>src/seahorse/utils/custom_exceptions.py</code> <pre><code>class NoTournamentFailError(Exception):\n    \"\"\"Thrown when trying to generate an action that's not permitted\n    \"\"\"\n\n    def __init__(self,  message: str = \"Tournament problem : tournament is none, please connect to an existing tournament or create a tournament\"):\n        self.message = message\n        super().__init__(message)\n</code></pre>"},{"location":"reference/seahorse/utils/custom_exceptions/#seahorse.utils.custom_exceptions.NotRunningError","title":"<code>NotRunningError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Thrown when trying to stop somethin twice</p> Source code in <code>src/seahorse/utils/custom_exceptions.py</code> <pre><code>class NotRunningError(Exception):\n    \"\"\"Thrown when trying to stop somethin twice\n    \"\"\"\n\n    def __init__(self,  message: str = \"Trying to stop something twice !\"):\n        self.message = message\n        super().__init__(message)\n</code></pre>"},{"location":"reference/seahorse/utils/custom_exceptions/#seahorse.utils.custom_exceptions.PlayerDuplicateError","title":"<code>PlayerDuplicateError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Thrown when trying to stop somethin twice</p> Source code in <code>src/seahorse/utils/custom_exceptions.py</code> <pre><code>class PlayerDuplicateError(Exception):\n    \"\"\"Thrown when trying to stop somethin twice\n    \"\"\"\n\n    def __init__(self,  message: str = \"Duplicates in the players list.\"):\n        self.message = message\n        super().__init__(message)\n</code></pre>"},{"location":"reference/seahorse/utils/custom_exceptions/#seahorse.utils.custom_exceptions.SeahorseTimeoutError","title":"<code>SeahorseTimeoutError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Thrown when trying to modify an expired element</p> Source code in <code>src/seahorse/utils/custom_exceptions.py</code> <pre><code>class SeahorseTimeoutError(Exception):\n    \"\"\"Thrown when trying to modify an expired element\n    \"\"\"\n\n    def __init__(self,  message: str = \"Trying to modify an expired element ! Time is out !\"):\n        self.message = message\n        super().__init__(message)\n</code></pre>"},{"location":"reference/seahorse/utils/custom_exceptions/#seahorse.utils.custom_exceptions.StopAndStartError","title":"<code>StopAndStartError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Thrown when trying to generate an action that's not permitted</p> Source code in <code>src/seahorse/utils/custom_exceptions.py</code> <pre><code>class StopAndStartError(Exception):\n    \"\"\"Thrown when trying to generate an action that's not permitted\n    \"\"\"\n\n    def __init__(self,  message: str = \"Timer was tampered with and exceeded the tolerancy set in GameMaster.\"):\n        self.message = message\n        super().__init__(message)\n</code></pre>"},{"location":"reference/seahorse/utils/custom_exceptions/#seahorse.utils.custom_exceptions.TimerNotInitializedError","title":"<code>TimerNotInitializedError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Thrown when trying to use timer utilities before timer initialization</p> Source code in <code>src/seahorse/utils/custom_exceptions.py</code> <pre><code>class TimerNotInitializedError(Exception):\n    \"\"\"Thrown when trying to use timer utilities before timer initialization\n    \"\"\"\n\n    def __init__(self,  message: str = \"Timer not initialized.\"):\n        self.message = message\n        super().__init__(message)\n</code></pre>"},{"location":"reference/seahorse/utils/gui_client/","title":"Gui client","text":""},{"location":"reference/seahorse/utils/recorders/","title":"Recorders","text":""},{"location":"reference/seahorse/utils/recorders/#seahorse.utils.recorders.StateRecorder","title":"<code>StateRecorder</code>","text":"<p>               Bases: <code>EventSlave</code></p> <p>An event slave that records everything state emitted by the master in a json file</p> Source code in <code>src/seahorse/utils/recorders.py</code> <pre><code>class StateRecorder(EventSlave):\n    \"\"\"\n    An event slave that records everything state emitted by the master in a json file\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.identifier = \"__REC__\"+str(int(time.time()*1000000-random.randint(1,1000000)))\n        self.id = builtins.id(self)\n        self.wrapped_id = self.id\n        self.sid = None\n\n        self.activate(self.identifier)\n\n        self.filepath = self.identifier + \".json\"\n         # Initialize file if needed\n        if not os.path.exists(self.filepath) or os.path.getsize(self.filepath) == 0:\n            with open(self.filepath, \"w\") as f:\n                json.dump({\"steps\": [], \"final_summary\": None}, f)\n\n        @self.sio.on(\"play\")\n        def record_play(data):\n            step = json.loads(data)\n            self.append_step(step)\n\n        @self.sio.on(\"done\")\n        def record_done(data):\n            final_summary = json.loads(data)\n            self.update_final_summary(final_summary)\n\n        @self.sio.event()\n        def disconnect():\n            pass\n\n    def append_step(self, step):\n        with open(self.filepath, \"r+\") as f:\n            content = json.load(f)\n            content[\"steps\"].append(step)\n            f.seek(0)\n            json.dump(content, f)\n            f.truncate()\n\n    def update_final_summary(self, final_summary):\n        with open(self.filepath, \"r+\") as f:\n            content = json.load(f)\n            content[\"final_summary\"] = final_summary\n            f.seek(0)\n            json.dump(content, f)\n            f.truncate()\n</code></pre>"},{"location":"reference/seahorse/utils/serializer/","title":"Serializer","text":""},{"location":"tutorials/1-getting_started/","title":"1 - Getting started","text":"<p>One simple way to get started is to play with the example first, let's quickly grab it from Seahorse's github repository:</p> <pre><code>git clone https://github.com/corail-research/seahorse/ \\\n--branch tictactoe \\\n--single-branch tictactoe\n</code></pre> <p>Once this is done just dive in, install seahorse if it's not already done and just launch a match between two of our pre-made autonomous agents.</p> <p><pre><code>cd tictactoe\npip install -r requirements.txt\npython main_tictac.py -t local random_player_tictac.py alpha_player_tictac.py \n</code></pre> A graphic interface should then appear in your browser.</p> Initial state Intermediate state Final state <p><code>seahorse</code> is the perfect framework to facilitate the implementation of adversarial agents. It helps developer to focus only on the very specific mechanics of the environment in which their agent will evolve. You don't lose time on game logic or execution utilities anymore. It has several features which includes for instance a multi-level log system, a game recorder, and a responsive GUI,.</p> <p></p>"},{"location":"tutorials/2-Building_Tic_Tac_Toe/","title":"2 - Building your first game","text":""},{"location":"tutorials/2-Building_Tic_Tac_Toe/#project-structure","title":"Project structure","text":"<p>Seahorse allows us to focus only on what's really needed for our game setup to work properly. Only a few files are needed to define our game-specific parameters:</p> <pre><code>\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 player_tictac.py\n\u251c\u2500\u2500 master_tictac.py\n\u251c\u2500\u2500 game_state_tictac.py\n\u251c\u2500\u2500 board_tictac.py\n\u2514\u2500\u2500 GUI\n    \u2514\u2500\u2500 index.html\n</code></pre>"},{"location":"tutorials/2-Building_Tic_Tac_Toe/#board-definition","title":"Board definition","text":"<p>First we need to import the metaclasses that we need in order to build a board configuration. Luckily as a board is a common setup for a game, an abstract class is provided by the framework.</p> <p>We need both game.game_layout.board.Board and game.game_layout.board.Piece. We also might want to import utils.serializer.Serializable for typing purposes.</p> <pre><code>import json\n\nfrom seahorse.game.game_layout.board import Board, Piece\nfrom seahorse.utils.serializer import Serializable\n</code></pre> <pre><code>class BoardTictac(Board):\n\n    def __init__(self, env: dict[tuple[int], Piece], dim: list[int]) -&gt; None:\n        super().__init__(env, dim)\n\n    def to_json(self) -&gt; dict:\n        return {\"env\":{str(x):y for x,y in self.env.items()},\n                \"dim\":self.dimensions}\n\n    @classmethod\n    def from_json(cls, data) -&gt; Serializable:\n        d = json.loads(data)\n        dd = json.loads(data)\n        for x,y in d[\"env\"].items():\n            del dd[\"env\"][x]\n            dd[\"env\"][eval(x)] = Piece.from_json(json.dumps(y))\n        return cls(**dd)\n</code></pre>"},{"location":"tutorials/2-Building_Tic_Tac_Toe/#describing-a-generic-game-state","title":"Describing a generic game state","text":"<p>We need to describe a specific state of the game in an appropriate way. To do so, we will inherit from  game.GameState.</p> <pre><code>import copy\nimport json\nfrom math import sqrt\nfrom typing import Optional\n\nfrom board_tictac import BoardTictac\nfrom loguru import logger\nfrom player_tictac import PlayerTictac\n\nfrom seahorse.game.action import Action\nfrom seahorse.game.game_layout.board import Piece\nfrom seahorse.game.game_state import GameState\nfrom seahorse.game.representation import Representation\nfrom seahorse.player.player import Player\nfrom seahorse.utils.serializer import Serializable\n\n\nclass GameStateTictac(GameState):\n\n    def __init__(self, scores: dict, next_player: Player, players: list[Player], rep: BoardTictac, *_, **__) -&gt; None:\n\n        super().__init__(scores, next_player, players, rep)\n        self.num_pieces = self.get_rep().get_dimensions()[0] * self.get_rep().get_dimensions()[1]\n\n    def get_num_pieces(self) -&gt; int:\n        return self.num_pieces\n</code></pre> <p>Let's start with the first function. It determines if the current game is finished (i.e. if all the cases are full or a player has won in our cases).</p> <pre><code>    def is_done(self) -&gt; bool:\n\n        if len(self.rep.get_env().keys()) == self.num_pieces or self.has_won():\n            return True\n        return False\n</code></pre> <p>We now need to implement the logic of the game, i.e. we need to determine which actions are possible.</p> <pre><code>    def generate_possible_actions(self) -&gt; set[Action]:\n        list_rep = []\n        current_rep = self.get_rep()\n        next_player = self.get_next_player()\n        for i in range(current_rep.get_dimensions()[0]):\n            for j in range(current_rep.get_dimensions()[1]):\n                if not current_rep.get_env().get((i, j)):\n                    copy_rep = copy.deepcopy(current_rep)\n                    copy_rep.get_env()[(i, j)] = Piece(piece_type=next_player.get_piece_type(), owner=next_player)\n                    list_rep.append(copy.deepcopy(copy_rep))\n        poss_actions = {\n            Action(\n                self,\n                GameStateTictac(\n                    self.compute_scores(valid_next_rep),\n                    self.compute_next_player(),\n                    self.players,\n                    valid_next_rep,\n                ),\n            )\n            for valid_next_rep in list_rep\n        }\n        return poss_actions\n</code></pre> <p>As for many games, a score will be involved. In tic-tac-toe, a player simply has a score of 1 if he succeeded to align three of its pieces, 0 otherwise.</p> <pre><code>    def compute_scores(self, representation: Representation) -&gt; dict[int, float]:\n\n        scores = {}\n        bound = 2.0\n        for player in self.players:\n            _, pieces = representation.get_pieces_player(player)\n            if len(pieces) &lt; representation.get_dimensions()[0]:\n                scores[player.get_id()] = 0.0\n            else:\n                success = False\n                env = representation.get_env()\n                dim = representation.get_dimensions()[0]\n                for i in range(dim):\n                    counter = 0.0\n                    for j in range(dim):\n                        if env.get((i, j), None) and env.get((i, j), None).get_owner_id() == player.get_id():\n                            counter += 1.0\n                    if counter &gt; bound:\n                        scores[player.get_id()] = 1.0\n                        success = True\n                if success:\n                    continue\n                for i in range(dim):\n                    counter = 0.0\n                    for j in range(dim):\n                        if env.get((j, i), None) and env.get((j, i), None).get_owner_id() == player.get_id():\n                            counter += 1.0\n                    if counter &gt; bound:\n                        scores[player.get_id()] = 1.0\n                        success = True\n                if success:\n                    continue\n                counter = 0.0\n                for i in range(dim):\n                    if env.get((i, i), None) and env.get((i, i), None).get_owner_id() == player.get_id():\n                        counter += 1.0\n                if counter &gt; bound:\n                    scores[player.get_id()] = 1.0\n                    success = True\n                if success:\n                    continue\n                counter = 0.0\n                for i in range(dim):\n                    if (\n                        env.get((i, dim - 1 - i), None)\n                        and env.get((i, dim - 1 - i), None).get_owner_id() == player.get_id()\n                    ):\n                        counter += 1.0\n                if counter &gt; bound:\n                    scores[player.get_id()] = 1.0\n                    success = True\n                if success:\n                    continue\n                else:\n                    scores[player.get_id()] = 0.0\n        return scores\n</code></pre> <p>It is finally useful to know if a specific game state is a winning state or not.   </p> <pre><code>    def has_won(self) -&gt; bool:\n        dim = self.get_num_pieces()\n        env = self.rep.get_env()\n        table = []\n        for k in range(dim):\n            table.append(\n                [p.get_owner_id() for p in [env.get((i, k), None) for i in range(int(sqrt(dim)))] if p is not None]\n            )\n            table.append(\n                [p.get_owner_id() for p in [env.get((k, i), None) for i in range(int(sqrt(dim)))] if p is not None]\n            )\n        table.append(\n            [p.get_owner_id() for p in [env.get((i, i), None) for i in range(int(sqrt(dim)))] if p is not None]\n        )\n        table.append(\n            [\n                p.get_owner_id()\n                for p in [env.get((i, int(sqrt(dim)) - i - 1), None) for i in range(int(sqrt(dim)))]\n                if p is not None\n            ]\n        )\n        for line in table:\n            if len(set(line)) == 1 and len(line) == int(sqrt(dim)):\n                return True\n        return False\n</code></pre> <p>Others functions are also there for convenience.</p> <pre><code>    def __str__(self) -&gt; str:\n        if not self.is_done():\n            return super().__str__()\n        return \"The game is finished!\"\n\n    def to_json(self) -&gt; dict:\n        return { i:j for i,j in self.__dict__.items() if i!=\"_possible_actions\"}\n\n    def convert_light_action_to_action(self,data:dict) -&gt; Action:\n        position = int(data[\"position\"])\n        logger.debug(f\"Converting light action {data}\")\n        i = position//3\n        j = position%3\n        logger.debug(f\"{i}{j}\")\n        for action in self.get_possible_actions():\n            if action.get_next_game_state().get_rep().get_env().get((i,j),None) is not None:\n                return action\n        return None\n\n    @classmethod\n    def from_json(cls,data:str,*,next_player:Optional[PlayerTictac]=None) -&gt; Serializable:\n        d = json.loads(data)\n        return cls(**{**d,\n            \"scores\":{int(k):v for k,v in d[\"scores\"].items()},\n            \"players\":[PlayerTictac.from_json(json.dumps(x)) \n                if not isinstance(x,str) \n                else next_player \n                for x in d[\"players\"]\n                ],\n            \"next_player\":next_player,\"rep\":BoardTictac.from_json(json.dumps(d[\"rep\"]))\n        })\n</code></pre>"},{"location":"tutorials/2-Building_Tic_Tac_Toe/#building-a-game-master","title":"Building a game master","text":"<p>As in every game wether it's a couple words on the back of the box or a game master, something or someone needs to dictate de rules and design a winner when the time comes.</p> <p>It's the same here, we need to have an entity that can distinguish the winner from the other players at the end of the game.</p> <pre><code>from collections.abc import Iterable\n\nfrom seahorse.game.game_state import GameState\nfrom seahorse.game.master import GameMaster\nfrom seahorse.player.player import Player\n\n\nclass MasterTictac(GameMaster):\n\n    def __init__(self, \n        name: str,\n        initial_game_state: GameState, \n        players_iterator: Iterable[Player], \n        log_level: str, \n        port: int = 8080, \n        hostname: str = \"localhost\"\n     ) -&gt; None:\n        super().__init__(name, initial_game_state, players_iterator, log_level, port, hostname)\n\n    def compute_winner(self, scores: dict[int, float]) -&gt; list[Player]:\n        max_val = max(scores.values())\n        players_id = [key for key in scores if scores[key] == max_val]\n        winners = [player for player in self.players if player.get_id() in players_id]\n        if len(winners) &gt; 1 :\n            winners = [winners[0]]\n        return winners\n</code></pre>"},{"location":"tutorials/2-Building_Tic_Tac_Toe/#creating-your-first-player","title":"Creating your first player","text":"<p>We define a first class which will contain general methods useful to every type of players.</p> <pre><code>import json\n\nfrom seahorse.player.player import Player\nfrom seahorse.utils.serializer import Serializable\n\n\nclass PlayerTictac(Player):\n\n    def __init__(self, piece_type: str, name: str = \"bob\", **kwargs) -&gt; None:\n        super().__init__(name,**kwargs)\n        self.piece_type = piece_type\n\n    def get_piece_type(self) -&gt; str:\n        return self.piece_type\n\n\n    def to_json(self) -&gt; dict:\n        return {i:j for i,j in self.__dict__.items() if i!=\"timer\"}\n\n    @classmethod\n    def from_json(cls, data) -&gt; Serializable:\n        return PlayerTictac(**json.loads(data))\n</code></pre> <p>Now, we will first try to do a basic random player. </p> <pre><code>import random\n\nfrom player_tictac import PlayerTictac\n\nfrom seahorse.game.action import Action\nfrom seahorse.game.game_state import GameState\n\n\nclass MyPlayer(PlayerTictac):\n    \"\"\"\n    A player class for Tic Tac Toe that selects moves randomly.\n    \"\"\"\n\n    def __init__(self, piece_type: str, name: str = \"bob\") -&gt; None:\n        \"\"\"\n        Initializes a new instance of the RandomPlayerTictac class.\n\n        Args:\n            piece_type (str): The type of the player's game piece.\n            name (str): The name of the player.\n        \"\"\"\n        super().__init__(piece_type, name)\n\n    def compute_action(self, current_state: GameState, **kwargs) -&gt; Action:\n        \"\"\"\n        Implements the logic of the player by randomly selecting a feasible move.\n\n        Args:\n            current_state (GameState): The current game state.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            Action: The selected action.\n        \"\"\"\n        possible_actions = current_state.generate_possible_actions()\n\n        return random.choice(list(possible_actions))\n</code></pre> <p>Of course more complex (and intelligent !) players are possible. To check your general understanding of the package, it would be interesting to implement an agent based on an alpha-beta algorithm.</p>"},{"location":"tutorials/2-Building_Tic_Tac_Toe/#bringing-it-all-together","title":"Bringing it all together","text":"<p>Now that we have all our class and methods, we can launch locally tic-tac-toe with the help of a very simple parser in a main file.</p> <pre><code>import argparse\nimport os\nfrom os.path import basename, splitext, dirname\nimport sys\nfrom board_tictac import BoardTictac\nfrom master_tictac import MasterTictac\nfrom game_state_tictac import GameStateTictac\nfrom seahorse.utils.gui_client import GUIClient\n\ndef play(player1, player2, log_level, port, gui, gui_path, address) :\n    list_players = [player1, player2]\n    init_scores = {player1.get_id(): 0, player2.get_id(): 0}\n    init_rep = BoardTictac(env={}, dim=[3, 3])\n    initial_game_state = GameStateTictac(\n        scores=init_scores, next_player=player1, players=list_players, rep=init_rep)\n    master = MasterTictac(\n        name=\"Tic-Tac-Toe\", initial_game_state=initial_game_state, players_iterator=list_players, log_level=log_level, port=port, hostname=address\n    )\n    listeners = [GUIClient(path=gui_path)]*gui\n    master.record_game(listeners=listeners)\n\nif __name__==\"__main__\":\n    parser = argparse.ArgumentParser(\n                        prog=\"Launcher\",\n                        description=\"What the program does\",\n                        epilog=\"Text at the bottom of help\")\n    parser.add_argument(\"list_players\",nargs=\"*\")\n    args=parser.parse_args()\n\n    list_players = vars(args).get(\"list_players\")\n\n    folder = dirname(list_players[0])\n    sys.path.append(folder)\n    player1_class = __import__(splitext(basename(list_players[0]))[0], fromlist=[None])\n    folder = dirname(list_players[1])\n    sys.path.append(folder)\n    player2_class = __import__(splitext(basename(list_players[1]))[0], fromlist=[None])\n    player1 = player1_class.MyPlayer(\"X\", name=splitext(basename(list_players[0]))[0])\n    player2 = player2_class.MyPlayer(\"O\", name=splitext(basename(list_players[1]))[0])\n    play(player1=player1, player2=player2, log_level=\"INFO\", port=16001, gui=1, gui_path=os.path.join(\"GUI\",\"index.html\"), address=\"localhost\")\n</code></pre> <p>We can duplicate our random player class in two different python files which do not have the same name. We call them player1 and player2. We can finally do the command line:</p> <pre><code>python main.py player1.py player2.py\n</code></pre> <p>Your first game is launched !</p>"},{"location":"tutorials/3-playing_across_the_internet/","title":"3 - Playing across the internet","text":"<p>Several mode of executions are possible with our previous implementation of tic-tac-toe. Below is an example of a main file.</p> <p>First, we define a play function which will be used in all the modes. <pre><code>import argparse\nimport asyncio\nimport os\nfrom os.path import basename, splitext, dirname\nimport sys\nfrom board_tictac import BoardTictac\nfrom player_tictac import PlayerTictac\nfrom master_tictac import MasterTictac\nfrom game_state_tictac import GameStateTictac\nfrom seahorse.player.proxies import InteractivePlayerProxy, LocalPlayerProxy, RemotePlayerProxy\nfrom seahorse.utils.gui_client import GUIClient\nfrom seahorse.utils.recorders import StateRecorder\n\ndef play(player1, player2, log_level, port, gui, gui_dist, gui_path, record, address) :\n    list_players = [player1, player2]\n    init_scores = {player1.get_id(): 0, player2.get_id(): 0}\n    init_rep = BoardTictac(env={}, dim=[3, 3])\n    initial_game_state = GameStateTictac(\n        scores=init_scores, next_player=player1, players=list_players, rep=init_rep)\n    master = MasterTictac(\n        name=\"Tic-Tac-Toe\", initial_game_state=initial_game_state, players_iterator=list_players, log_level=log_level, port=port, hostname=address\n    )\n    listeners = [GUIClient(path=gui_path)]*gui+[GUIClient()]*gui_dist\n    if record :\n        listeners.append(StateRecorder())\n    master.record_game(listeners=listeners)\n</code></pre> Let's now implement a parser to easily launch our program with command line. <pre><code>if __name__==\"__main__\":\n    parser = argparse.ArgumentParser(\n                        prog=\"Launcher\",\n                        description=\"What the program does\",\n                        epilog=\"Text at the bottom of help\")\n    parser.add_argument(\"-t\",\"--type\",required=True,type=str, choices=[\"local\", \"remote\", \"standalone\", \"humvscomp\", \"humvshum\"])\n    parser.add_argument(\"-n\",\"--nb_players\",required=False,type=int, default=2)\n    parser.add_argument(\"-add\",\"--address\",required=False, default=\"localhost\")\n    parser.add_argument(\"-p\",\"--port\",required=False,type=int, default=16001)\n    parser.add_argument(\"-g\",\"--gui\",required=False,type=int, default=0)\n    parser.add_argument(\"-gd\",\"--gui_dist\",required=False,type=int, default=0)\n    parser.add_argument(\"-gp\",\"--gui_path\",required=False,type=str, default=os.path.join(\"GUI\",\"index.html\"))\n    parser.add_argument(\"-r\",\"--record\",action=\"store_true\",default=False)\n    parser.add_argument(\"-l\",\"--log\",required=False,choices=[\"DEBUG\",\"INFO\"], default=\"INFO\")\n    parser.add_argument(\"list_players\",nargs=\"*\")\n    args=parser.parse_args()\n\n    type = vars(args).get(\"type\")\n    nb_players = vars(args).get(\"nb_players\")\n    address = vars(args).get(\"address\")\n    port = vars(args).get(\"port\")\n    gui = vars(args).get(\"gui\")\n    gui_dist = vars(args).get(\"gui_dist\")\n    gui_path = vars(args).get(\"gui_path\")\n    record = vars(args).get(\"record\")\n    log_level = vars(args).get(\"log\")\n    list_players = vars(args).get(\"list_players\")\n\n    if type == \"local\" :\n        folder = dirname(list_players[0])\n        sys.path.append(folder)\n        player1_class = __import__(splitext(basename(list_players[0]))[0], fromlist=[None])\n        folder = dirname(list_players[1])\n        sys.path.append(folder)\n        player2_class = __import__(splitext(basename(list_players[1]))[0], fromlist=[None])\n        player1 = player1_class.MyPlayer(\"X\", name=splitext(basename(list_players[0]))[0])\n        player2 = player2_class.MyPlayer(\"O\", name=splitext(basename(list_players[1]))[0])\n        play(player1=player1, player2=player2, log_level=log_level, port=port, gui=gui, gui_dist=gui_dist, gui_path=gui_path, record=record, address=address)\n    elif type == \"remote\" :\n        folder = dirname(list_players[0])\n        sys.path.append(folder)\n        player1_class = __import__(splitext(basename(list_players[0]))[0], fromlist=[None])\n        player1 = LocalPlayerProxy(player1_class.MyPlayer(\"X\", name=splitext(basename(list_players[0]))[0]),gs=GameStateTictac)\n        player2 = RemotePlayerProxy(mimics=PlayerTictac,piece_type=\"O\",name=splitext(basename(list_players[1]))[0])\n        play(player1=player1, player2=player2, log_level=log_level, port=port, gui=gui, gui_dist=gui_dist, gui_path=gui_path, record=record, address=address)\n    elif type == \"standalone\" :\n        folder = dirname(list_players[0])\n        sys.path.append(folder)\n        player2_class = __import__(splitext(basename(list_players[0]))[0], fromlist=[None])\n        player2 = LocalPlayerProxy(player2_class.MyPlayer(\"O\", name=splitext(basename(list_players[0]))[0]),gs=GameStateTictac)\n        asyncio.new_event_loop().run_until_complete(player2.listen(keep_alive=True,master_address=f\"http://{address}:{port}\"))\n    elif type == \"humvscomp\" :\n        folder = dirname(list_players[0])\n        sys.path.append(folder)\n        player1_class = __import__(splitext(basename(list_players[0]))[0], fromlist=[None])\n        player1 = InteractivePlayerProxy(PlayerTictac(\"X\", name=\"bob\"),gui_path=gui_path,gs=GameStateTictac)\n        player2 = LocalPlayerProxy(player1_class.MyPlayer(\"O\", name=splitext(basename(list_players[0]))[0]),gs=GameStateTictac)\n        play(player1=player1, player2=player2, log_level=log_level, port=port, gui=0, gui_dist=gui_dist, gui_path=gui_path, record=record, address=address)\n    elif type == \"humvshum\" :\n        player1 = InteractivePlayerProxy(PlayerTictac(\"X\", name=\"bob\"),gui_path=gui_path,gs=GameStateTictac)\n        player2 = InteractivePlayerProxy(PlayerTictac(\"O\", name=\"alice\"),gs=GameStateTictac)\n        play(player1=player1, player2=player2, log_level=log_level, port=port, gui=0, gui_dist=gui_dist, gui_path=gui_path, record=record, address=address)\n</code></pre></p>"},{"location":"tutorials/4-Recording_games/","title":"4 - Recording games","text":""},{"location":"tutorials/5-Parallelization/","title":"5 - Parallelization","text":""},{"location":"tutorials/6-Using%20the%20Challonge%20API/","title":"6 - Using the Challonge API","text":""}]}